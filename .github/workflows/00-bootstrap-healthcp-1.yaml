# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BOOTSTRAP INFRASTRUCTURE - healthcp-1
# Generated by Code-to-Cloud Enterprise v0.903
# RULE 2: Bootstrap MUST complete before CI/CD
# RULE 61: Auto-register spoke cluster with ArgoCD hub
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "00-Bootstrap: healthcp-1"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to bootstrap'
        type: string
        default: 'dev'
      proceed:
        description: 'Confirm to proceed with bootstrap'
        type: boolean
        default: false
        required: true

env:
  APP_NAME: healthcp-1
  TENANT: opsera
  AWS_REGION: us-west-2
  EKS_HUB_CLUSTER: argocd-usw2
  EKS_SPOKE_CLUSTER: opsera-usw2-np
  ECR_REPOSITORY: opsera/healthcp-1
  DOMAIN: agent.opsera.dev

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERIFY PREREQUISITES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-prerequisites:
    name: "ğŸ” Verify Prerequisites"
    runs-on: ubuntu-latest
    if: inputs.proceed == true
    outputs:
      spoke_registered: ${{ steps.check-spoke.outputs.registered }}
      ecr_exists: ${{ steps.check-ecr.outputs.exists }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID (RULE 7)
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "AWS Account: ${AWS_ACCOUNT_ID}"

      - name: Check Spoke Cluster Exists (RULE 90)
        id: check-spoke
        run: |
          set +e
          aws eks describe-cluster --name ${{ env.EKS_SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… Spoke cluster exists: ${{ env.EKS_SPOKE_CLUSTER }}"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Spoke cluster NOT found: ${{ env.EKS_SPOKE_CLUSTER }}"
            echo "exists=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Check Spoke Registered in ArgoCD
        id: check-spoke-registered
        run: |
          set +e
          kubectl get secret "cluster-${{ env.EKS_SPOKE_CLUSTER }}" -n argocd > /dev/null 2>&1
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… Spoke cluster registered in ArgoCD"
            echo "registered=true" >> $GITHUB_OUTPUT
          else
            echo "ğŸ“ Spoke cluster needs registration"
            echo "registered=false" >> $GITHUB_OUTPUT
          fi

      - name: Check ECR Repository
        id: check-ecr
        run: |
          set +e
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} > /dev/null 2>&1
          EXIT_CODE=$?
          set -e
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… ECR repository exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "ğŸ“ ECR repository needs creation"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CREATE ECR REPOSITORY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-ecr:
    name: "ğŸ“¦ Create ECR Repository"
    runs-on: ubuntu-latest
    needs: [verify-prerequisites]
    if: needs.verify-prerequisites.outputs.ecr_exists == 'false'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create ECR Repository (RULE 75)
        run: |
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --region ${{ env.AWS_REGION }} \
            --image-scanning-configuration scanOnPush=true \
            --tags Key=tenant,Value=${{ env.TENANT }} Key=app,Value=${{ env.APP_NAME }}
          
          echo "âœ… ECR repository created: ${{ env.ECR_REPOSITORY }}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # REGISTER SPOKE CLUSTER (RULE 103)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  register-spoke:
    name: "ğŸ”— Register Spoke Cluster"
    runs-on: ubuntu-latest
    needs: [verify-prerequisites]
    if: needs.verify-prerequisites.outputs.spoke_registered == 'false'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Spoke Cluster Details
        id: spoke-details
        run: |
          SPOKE_ENDPOINT=$(aws eks describe-cluster --name ${{ env.EKS_SPOKE_CLUSTER }} --query 'cluster.endpoint' --output text)
          SPOKE_CA=$(aws eks describe-cluster --name ${{ env.EKS_SPOKE_CLUSTER }} --query 'cluster.certificateAuthority.data' --output text)
          
          echo "endpoint=${SPOKE_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "ca=${SPOKE_CA}" >> $GITHUB_OUTPUT

      - name: Create ServiceAccount on Spoke
        run: |
          # Configure kubectl for spoke cluster
          aws eks update-kubeconfig --name ${{ env.EKS_SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          # Create argocd-manager ServiceAccount
          kubectl create namespace argocd-manager --dry-run=client -o yaml | kubectl apply -f -
          
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: ServiceAccount
          metadata:
            name: argocd-manager
            namespace: kube-system
          ---
          apiVersion: rbac.authorization.k8s.io/v1
          kind: ClusterRoleBinding
          metadata:
            name: argocd-manager-role
          roleRef:
            apiGroup: rbac.authorization.k8s.io
            kind: ClusterRole
            name: cluster-admin
          subjects:
            - kind: ServiceAccount
              name: argocd-manager
              namespace: kube-system
          EOF

      - name: Create Token for ArgoCD (RULE 62)
        id: create-token
        run: |
          # K8s 1.24+ requires manual token creation
          TOKEN=$(kubectl create token argocd-manager -n kube-system --duration=87600h)
          echo "token=${TOKEN}" >> $GITHUB_OUTPUT

      - name: Register Cluster in ArgoCD Hub
        run: |
          # Configure kubectl for hub cluster
          aws eks update-kubeconfig --name ${{ env.EKS_HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          
          SPOKE_ENDPOINT="${{ steps.spoke-details.outputs.endpoint }}"
          SPOKE_CA="${{ steps.spoke-details.outputs.ca }}"
          TOKEN="${{ steps.create-token.outputs.token }}"
          
          # Create cluster secret in ArgoCD
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Secret
          metadata:
            name: cluster-${{ env.EKS_SPOKE_CLUSTER }}
            namespace: argocd
            labels:
              argocd.argoproj.io/secret-type: cluster
          type: Opaque
          stringData:
            name: ${{ env.EKS_SPOKE_CLUSTER }}
            server: "${SPOKE_ENDPOINT}"
            config: |
              {
                "bearerToken": "${TOKEN}",
                "tlsClientConfig": {
                  "insecure": false,
                  "caData": "${SPOKE_CA}"
                }
              }
          EOF
          
          echo "âœ… Spoke cluster registered in ArgoCD"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE CONFIGURATION FILES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-config:
    name: "ğŸ“ Update Configuration"
    runs-on: ubuntu-latest
    needs: [verify-prerequisites, create-ecr, register-spoke]
    if: |
      always() &&
      needs.verify-prerequisites.result == 'success' &&
      (needs.create-ecr.result == 'success' || needs.create-ecr.result == 'skipped') &&
      (needs.register-spoke.result == 'success' || needs.register-spoke.result == 'skipped')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Update Placeholders (RULE 87)
        env:
          AWS_ACCOUNT_ID: ${{ steps.aws-account.outputs.account_id }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          HOSTNAME="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENVIRONMENT}.${{ env.DOMAIN }}"
          
          # Update ArgoCD application
          sed -i "s|PLACEHOLDER_REPO_URL|${REPO_URL}|g" .opsera-${{ env.APP_NAME }}/argocd/${ENVIRONMENT}/application.yaml
          
          # Update kustomization overlay
          sed -i "s|PLACEHOLDER_ECR_URI|${ECR_URI}|g" .opsera-${{ env.APP_NAME }}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml
          
          echo "âœ… Updated configuration files"
          echo "ECR URI: ${ECR_URI}"
          echo "Repo URL: ${REPO_URL}"
          echo "Hostname: ${HOSTNAME}"

      - name: Commit Changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .opsera-${{ env.APP_NAME }}/
          
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: Bootstrap ${{ env.APP_NAME }} for ${{ inputs.environment }} environment [skip ci]"
            git pull --rebase origin main
            git push origin main
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CREATE ARGOCD REPOSITORY SECRET (RULE 63)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-repo-secret:
    name: "ğŸ”‘ Create Repository Secret"
    runs-on: ubuntu-latest
    needs: [update-config]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create ArgoCD Repository Secret (RULE 63)
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          REPO_URL="https://github.com/${{ github.repository }}"
          SECRET_NAME="repo-${{ env.APP_NAME }}"
          
          # Check if secret exists
          if kubectl get secret "${SECRET_NAME}" -n argocd > /dev/null 2>&1; then
            echo "âœ… Repository secret already exists"
          else
            kubectl create secret generic "${SECRET_NAME}" -n argocd \
              --from-literal=type=git \
              --from-literal=url="${REPO_URL}" \
              --from-literal=username=git \
              --from-literal=password="${GH_PAT}"
            
            kubectl label secret "${SECRET_NAME}" -n argocd \
              argocd.argoproj.io/secret-type=repository
            
            echo "âœ… Repository secret created"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # APPLY ARGOCD APPLICATION
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  apply-argocd-app:
    name: "ğŸš€ Apply ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [create-repo-secret]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Apply ArgoCD Application
        run: |
          git pull origin main
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/${{ inputs.environment }}/application.yaml
          echo "âœ… ArgoCD Application applied for ${{ inputs.environment }}"

      - name: Verify Application Created
        run: |
          sleep 5
          kubectl get application ${{ env.APP_NAME }}-${{ inputs.environment }} -n argocd
          echo "âœ… ArgoCD Application created successfully"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ğŸ“‹ Summary"
    runs-on: ubuntu-latest
    needs: [apply-argocd-app]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          cat << EOF >> $GITHUB_STEP_SUMMARY
          # ğŸ‰ Bootstrap Complete: ${{ env.APP_NAME }}
          
          ## Configuration
          | Setting | Value |
          |---------|-------|
          | **App Name** | \`${{ env.APP_NAME }}\` |
          | **Tenant** | \`${{ env.TENANT }}\` |
          | **Environment** | \`${{ inputs.environment }}\` |
          | **Region** | \`${{ env.AWS_REGION }}\` |
          | **Spoke Cluster** | \`${{ env.EKS_SPOKE_CLUSTER }}\` |
          
          ## Resources Created
          - âœ… ECR Repository: \`${{ env.ECR_REPOSITORY }}\`
          - âœ… Spoke Cluster Registration
          - âœ… ArgoCD Repository Secret
          - âœ… ArgoCD Application
          
          ## Next Steps
          1. **Push code changes** to trigger CI/CD:
             \`\`\`bash
             git push origin main
             \`\`\`
          
          2. **Or trigger CI/CD manually**:
             \`\`\`bash
             gh workflow run "01-CI Build Push: healthcp-1" -f environment=${{ inputs.environment }}
             \`\`\`
          
          ## Application URL (after deployment)
          \`\`\`
          https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}.${{ env.DOMAIN }}
          \`\`\`
          EOF
