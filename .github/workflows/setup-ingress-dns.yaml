# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HEALTHCP: Setup Ingress, DNS & SSL
# Installs NGINX Ingress Controller, creates Route53 DNS, configures SSL
# Generated by Opsera Code-to-Cloud Enterprise v1.4
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "ðŸŒ Setup Ingress & DNS"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - qa
          - staging
        default: 'dev'

env:
  AWS_REGION: us-east-1
  WORKLOAD_CLUSTER: opsera-use1-np
  DOMAIN: agent.opsera.dev
  APP_NAME: healthcp

jobs:
  setup-ingress-dns:
    name: "ðŸŒ Setup Ingress & DNS"
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl and Helm
        run: |
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/v1.29.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          
          # Install Helm
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.WORKLOAD_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl cluster-info
          echo "âœ… Connected to cluster: ${{ env.WORKLOAD_CLUSTER }}" >> $GITHUB_STEP_SUMMARY

      - name: Install NGINX Ingress Controller
        run: |
          echo "### ðŸ“¦ Installing NGINX Ingress Controller" >> $GITHUB_STEP_SUMMARY
          
          # Add NGINX Ingress Helm repo
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          
          # Check if release is stuck and fix it
          RELEASE_STATUS=$(helm status ingress-nginx -n ingress-nginx 2>/dev/null | grep STATUS || echo "")
          if [[ "$RELEASE_STATUS" == *"pending"* ]] || [[ "$RELEASE_STATUS" == *"failed"* ]]; then
            echo "Detected stuck/failed release, rolling back..."
            helm rollback ingress-nginx -n ingress-nginx 2>/dev/null || true
            sleep 5
          fi
          
          # Install or upgrade NGINX Ingress with --atomic for auto-rollback
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx \
            --create-namespace \
            --set controller.service.type=LoadBalancer \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-scheme"=internet-facing \
            --wait --timeout 5m \
            --atomic || {
              # If still failing, force cleanup and retry
              echo "Retry with force cleanup..."
              helm uninstall ingress-nginx -n ingress-nginx --wait 2>/dev/null || true
              sleep 10
              helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                --namespace ingress-nginx \
                --create-namespace \
                --set controller.service.type=LoadBalancer \
                --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"=nlb \
                --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-scheme"=internet-facing \
                --wait --timeout 5m
            }
          
          echo "âœ… NGINX Ingress Controller installed" >> $GITHUB_STEP_SUMMARY

      - name: Wait for LoadBalancer
        id: lb
        run: |
          echo "Waiting for LoadBalancer to be assigned..."
          
          for i in {1..30}; do
            LB_HOSTNAME=$(kubectl get svc ingress-nginx-controller -n ingress-nginx \
              -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            
            if [ -n "$LB_HOSTNAME" ]; then
              echo "hostname=$LB_HOSTNAME" >> $GITHUB_OUTPUT
              echo "âœ… LoadBalancer hostname: \`$LB_HOSTNAME\`" >> $GITHUB_STEP_SUMMARY
              break
            fi
            
            echo "Waiting... ($i/30)"
            sleep 10
          done
          
          if [ -z "$LB_HOSTNAME" ]; then
            echo "âŒ Failed to get LoadBalancer hostname" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Install cert-manager for SSL
        run: |
          echo "### ðŸ”’ Installing cert-manager for SSL" >> $GITHUB_STEP_SUMMARY
          
          # Install cert-manager
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.14.0/cert-manager.yaml
          
          # Wait for cert-manager to be ready
          kubectl wait --for=condition=available deployment/cert-manager -n cert-manager --timeout=120s || true
          kubectl wait --for=condition=available deployment/cert-manager-webhook -n cert-manager --timeout=120s || true
          
          sleep 30
          
          # Create ClusterIssuer for Let's Encrypt
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: devops@opsera.io
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF
          
          echo "âœ… cert-manager installed with Let's Encrypt issuer" >> $GITHUB_STEP_SUMMARY

      - name: Discover Route53 Hosted Zone
        id: route53
        run: |
          echo "### ðŸ” Discovering Route53 Hosted Zone" >> $GITHUB_STEP_SUMMARY
          
          # Find hosted zone for agent.opsera.dev or opsera.dev
          HOSTED_ZONES=$(aws route53 list-hosted-zones --query 'HostedZones[*].[Id,Name]' --output text)
          echo "Available hosted zones:"
          echo "$HOSTED_ZONES"
          
          # Try to find matching zone
          ZONE_ID=""
          for domain in "agent.opsera.dev." "opsera.dev."; do
            ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?Name=='$domain'].Id" --output text | sed 's|/hostedzone/||')
            if [ -n "$ZONE_ID" ]; then
              echo "Found zone for $domain: $ZONE_ID"
              break
            fi
          done
          
          if [ -z "$ZONE_ID" ]; then
            echo "âš ï¸ No matching hosted zone found for agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
            echo "Available zones:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$HOSTED_ZONES" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "zone_id=" >> $GITHUB_OUTPUT
          else
            echo "zone_id=$ZONE_ID" >> $GITHUB_OUTPUT
            echo "âœ… Found hosted zone: \`$ZONE_ID\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create Route53 DNS Record
        if: steps.route53.outputs.zone_id != ''
        env:
          ZONE_ID: ${{ steps.route53.outputs.zone_id }}
          LB_HOSTNAME: ${{ steps.lb.outputs.hostname }}
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          FQDN="${{ env.APP_NAME }}-${ENVIRONMENT}.${{ env.DOMAIN }}"
          
          echo "Creating DNS record: $FQDN -> $LB_HOSTNAME"
          
          cat > /tmp/dns-change.json << EOF
          {
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$FQDN",
                "Type": "CNAME",
                "TTL": 300,
                "ResourceRecords": [{"Value": "$LB_HOSTNAME"}]
              }
            }]
          }
          EOF
          
          aws route53 change-resource-record-sets \
            --hosted-zone-id $ZONE_ID \
            --change-batch file:///tmp/dns-change.json
          
          echo "### âœ… DNS Record Created" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Record | \`$FQDN\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Type | CNAME |" >> $GITHUB_STEP_SUMMARY
          echo "| Target | \`$LB_HOSTNAME\` |" >> $GITHUB_STEP_SUMMARY

      - name: Update Existing Ingress with SSL
        env:
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          NAMESPACE="healthcp-${ENVIRONMENT}"
          FQDN="${{ env.APP_NAME }}-${ENVIRONMENT}.${{ env.DOMAIN }}"
          
          # Ensure namespace exists
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          
          # Check if ingress exists and update it
          EXISTING_INGRESS=$(kubectl get ingress -n $NAMESPACE -o name 2>/dev/null | head -1)
          
          if [ -n "$EXISTING_INGRESS" ]; then
            INGRESS_NAME=$(echo $EXISTING_INGRESS | cut -d'/' -f2)
            echo "Found existing ingress: $INGRESS_NAME - updating with SSL annotations"
            
            # Patch existing ingress with SSL annotations
            kubectl annotate ingress $INGRESS_NAME -n $NAMESPACE \
              cert-manager.io/cluster-issuer=letsencrypt-prod \
              nginx.ingress.kubernetes.io/ssl-redirect="true" \
              --overwrite || true
            
            # Update ingress with TLS config
            kubectl patch ingress $INGRESS_NAME -n $NAMESPACE --type=merge -p "{
              \"spec\": {
                \"ingressClassName\": \"nginx\",
                \"tls\": [{
                  \"hosts\": [\"$FQDN\"],
                  \"secretName\": \"healthcp-tls\"
                }]
              }
            }" || true
            
            echo "âœ… Updated existing ingress with SSL" >> $GITHUB_STEP_SUMMARY
          else
            # Create new ingress if none exists
            cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: healthcp
            namespace: $NAMESPACE
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            tls:
            - hosts:
              - $FQDN
              secretName: healthcp-tls
            rules:
            - host: $FQDN
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: healthcp
                      port:
                        number: 80
          EOF
            echo "âœ… Created new ingress with SSL" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### ðŸ”’ Ingress configured" >> $GITHUB_STEP_SUMMARY
          echo "Host: \`$FQDN\`" >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n $NAMESPACE

      - name: Verify Deployment Exists
        env:
          ENVIRONMENT: ${{ inputs.environment }}
        run: |
          NAMESPACE="healthcp-${ENVIRONMENT}"
          
          echo "### ðŸ“Š Deployment Status" >> $GITHUB_STEP_SUMMARY
          
          # Check if deployment exists
          if kubectl get deployment healthcp -n $NAMESPACE &>/dev/null; then
            kubectl get deployment healthcp -n $NAMESPACE -o wide
            kubectl get pods -n $NAMESPACE
            echo "âœ… Deployment found in namespace \`$NAMESPACE\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Deployment not found - run CI/CD pipeline first" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Check service
          if kubectl get svc healthcp -n $NAMESPACE &>/dev/null; then
            kubectl get svc healthcp -n $NAMESPACE
            echo "âœ… Service found" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Service not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Summary
        env:
          ENVIRONMENT: ${{ inputs.environment }}
          LB_HOSTNAME: ${{ steps.lb.outputs.hostname }}
        run: |
          FQDN="${{ env.APP_NAME }}-${ENVIRONMENT}.${{ env.DOMAIN }}"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸŽ‰ Setup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Endpoint" >> $GITHUB_STEP_SUMMARY
          echo "**Secure URL:** https://${FQDN}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### â³ SSL Certificate" >> $GITHUB_STEP_SUMMARY
          echo "The SSL certificate will be automatically provisioned by Let's Encrypt." >> $GITHUB_STEP_SUMMARY
          echo "This may take 2-5 minutes after DNS propagation." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Components Installed" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| NGINX Ingress | âœ… Installed |" >> $GITHUB_STEP_SUMMARY
          echo "| LoadBalancer | âœ… \`$LB_HOSTNAME\` |" >> $GITHUB_STEP_SUMMARY
          echo "| cert-manager | âœ… Installed |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Record | âœ… Created |" >> $GITHUB_STEP_SUMMARY
          echo "| Ingress | âœ… Configured |" >> $GITHUB_STEP_SUMMARY
