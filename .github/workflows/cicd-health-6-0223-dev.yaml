name: "CI/CD: health-6-0223-dev"

# Required Secrets:
# Core Infrastructure:
# - AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, GH_PAT
# Integrations:
# - SONAR_TOKEN + SONAR_HOST_URL (var)
# - SLACK_WEBHOOK_URL
# - NEWRELIC_LICENSE_KEY, NEWRELIC_API_KEY, NEWRELIC_ACCOUNT_ID
# - DATADOG_API_KEY, DATADOG_APP_KEY
# - JIRA_API_TOKEN, JIRA_BASE_URL + JIRA_PROJECT (var)

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "**/*.md"
      - ".github/workflows/**"
      - ".opsera-**/**"
      - "**/deployment-landscape-*.yaml"
  workflow_dispatch:
    inputs:
      action:
        description: "Action (deploy|rollback)"
        default: deploy

concurrency:
  group: ci-cd-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  APP_NAME: "health-6-0223"
  TENANT: "opsera"
  ENV: "dev"
  REGION: "us-west-2"
  ECR_REPO: "health-6-0223"
  NAMESPACE: "opsera-health-6-0223-dev"
  HUB_CLUSTER: "argocd-usw2"
  SPOKE_CLUSTER: "opsera-usw2-np"

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  # Stage 0: Bootstrap Prerequisites Check (BLOCKING)
  bootstrap-check:
    runs-on: ubuntu-latest
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Check Bootstrap Prerequisites
        id: check
        run: |
          FAILED=0
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPO }} --region ${{ env.REGION }} &>/dev/null; then
            echo "❌ ECR repository '${{ env.ECR_REPO }}' does not exist"
            echo "   Run: gh workflow run 00-bootstrap-health-6-0223.yaml"
            FAILED=1
          else
            echo "✅ ECR repository exists"
          fi
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          kubectl get namespace ${{ env.NAMESPACE }} --context spoke &>/dev/null && echo "✅ Namespace exists" || echo "⚠️ Namespace missing (ArgoCD will create)"
          [ $FAILED -eq 1 ] && exit 1
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "✅ All bootstrap prerequisites satisfied"

  # Stage 1: Jira Story Creation
  jira-create-story:
    runs-on: ubuntu-latest
    needs: bootstrap-check
    if: needs.bootstrap-check.outputs.ready == 'true'
    continue-on-error: true
    outputs:
      issue_key: ${{ steps.create.outputs.issue_key }}
    steps:
      - name: Create Jira Deployment Story
        id: create
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_PROJECT: ${{ vars.JIRA_PROJECT || 'OPS' }}
        run: |
          if [ -z "$JIRA_API_TOKEN" ] || [ -z "$JIRA_BASE_URL" ]; then
            echo "⚠️ Jira secrets not configured — skipping"
            echo "issue_key=SKIPPED" >> $GITHUB_OUTPUT
            exit 0
          fi
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          RESPONSE=$(curl -s -X POST "$JIRA_BASE_URL/rest/api/2/issue" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $JIRA_API_TOKEN" \
            -d "{\"fields\":{\"project\":{\"key\":\"$JIRA_PROJECT\"},\"summary\":\"Deploy ${{ env.APP_NAME }} ${{ env.ENV }} - ${SHORT_SHA}\",\"description\":\"Automated deployment via Opsera CI/CD\\nRepo: ${{ github.repository }}\\nBranch: ${{ github.ref_name }}\\nCommit: ${{ github.sha }}\",\"issuetype\":{\"name\":\"Story\"}}}")
          ISSUE_KEY=$(echo "$RESPONSE" | grep -o '"key":"[^"]*"' | head -1 | cut -d'"' -f4)
          echo "issue_key=${ISSUE_KEY}" >> $GITHUB_OUTPUT
          echo "✅ Jira story created: ${ISSUE_KEY}"

  # Stage 2: Security Scan (Gitleaks - warn only)
  security-scan:
    runs-on: ubuntu-latest
    needs: [bootstrap-check, jira-create-story]
    if: needs.bootstrap-check.outputs.ready == 'true'
    continue-on-error: true
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
      - name: Upload Gitleaks report
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: gitleaks-report-${{ github.sha }}
          path: results.sarif
          retention-days: 30

  # Stage 2B: SonarQube Code Quality Scan
  sonarqube-scan:
    runs-on: ubuntu-latest
    needs: [bootstrap-check, security-scan]
    if: needs.bootstrap-check.outputs.ready == 'true'
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}
      - name: SonarQube Quality Gate
        if: vars.SONARQUBE_MODE == 'block'
        uses: sonarsource/sonarqube-quality-gate-action@master
        continue-on-error: true
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # Stage 3: Build and Push
  build-push:
    runs-on: ubuntu-latest
    needs: [bootstrap-check, security-scan, sonarqube-scan]
    if: always() && needs.bootstrap-check.outputs.ready == 'true' && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped' || needs.security-scan.result == 'failure')
    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}
      ecr-uri: ${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Login to ECR
        id: login
        uses: aws-actions/amazon-ecr-login@v2
      - name: Set image tag (ENV-SHA-TIMESTAMP)
        id: tag
        run: |
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          TAG="${{ env.ENV }}-${SHORT_SHA}-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
      - name: Build and push
        run: |
          IMAGE_URI="${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}:${{ steps.tag.outputs.tag }}"
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfile -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}
      - name: Notify Slack - Build Success
        if: success()
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && exit 0
          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"text\":\"✅ *${{ env.APP_NAME }}* build succeeded\nImage: \`${{ steps.tag.outputs.tag }}\`\nBranch: \`${{ github.ref_name }}\`\nCommit: \`${{ github.sha }}\`\"}"

  # Stage 4: Container Scan (Grype - warn only)
  container-scan:
    runs-on: ubuntu-latest
    needs: build-push
    if: always() && needs.build-push.result == 'success'
    continue-on-error: true
    permissions:
      security-events: write
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2
      - name: Grype Vulnerability Scan
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: "${{ needs.build-push.outputs.ecr-uri }}:${{ needs.build-push.outputs.image-tag }}"
          fail-build: false
          severity-cutoff: ${{ vars.GRYPE_FAIL_SEVERITY || 'critical' }}
          output-format: sarif
      - name: Upload SARIF to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true
        with:
          sarif_file: results.sarif
      - name: Upload scan artifact
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: grype-scan-${{ env.ENV }}-${{ needs.build-push.outputs.image-tag }}
          path: results.sarif
          retention-days: 30
      - name: Send scan results to Datadog
        if: always()
        continue-on-error: true
        env:
          DD_API_KEY: ${{ secrets.DATADOG_API_KEY }}
        run: |
          [ -z "$DD_API_KEY" ] && exit 0
          curl -s -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "DD-API-KEY: $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"title\":\"Container scan: ${{ env.APP_NAME }}\",\"text\":\"Grype scan completed for ${{ needs.build-push.outputs.image-tag }}\",\"tags\":[\"service:${{ env.APP_NAME }}\",\"env:${{ env.ENV }}\",\"scan:grype\"]}"

  # Stage 5: Update Manifests
  update-manifests:
    runs-on: ubuntu-latest
    needs: [build-push, container-scan]
    if: always() && needs.build-push.result == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      - name: Update image tag in kustomization
        run: |
          KUSTOMIZATION=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENV }}/kustomization.yaml"
          ECR_URI="${{ needs.build-push.outputs.ecr-uri }}"
          IMAGE_TAG="${{ needs.build-push.outputs.image-tag }}"
          sed -i "s|newName: PLACEHOLDER_ECR_URI|newName: ${ECR_URI}|" "${KUSTOMIZATION}"
          sed -i "s/newTag: .*/newTag: ${IMAGE_TAG}/" "${KUSTOMIZATION}"
          echo "Updated: ${ECR_URI}:${IMAGE_TAG}"
          cat "${KUSTOMIZATION}"
      - name: Commit and push [skip ci]
        run: |
          git config user.name "opsera-agent"
          git config user.email "agent@opsera.dev"
          git add .opsera-${{ env.APP_NAME }}/k8s/
          git diff --staged --quiet || git commit -m "ci: update image tag ${{ needs.build-push.outputs.image-tag }} [skip ci]"
          git push || (git pull --rebase && git push)

  # Stage 6: Deploy (ArgoCD + ECR Secret + Sync + Verify)
  deploy:
    runs-on: ubuntu-latest
    needs: [update-manifests, jira-create-story]
    if: always() && needs.update-manifests.result == 'success'
    outputs:
      deployed: ${{ steps.verify.outputs.deployed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
      - name: Connect to Hub Cluster (ArgoCD)
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.REGION }} --alias hub
          kubectl config use-context hub
      - name: Create/Update ArgoCD Application (Idempotent)
        run: |
          kubectl --context hub apply -f ".opsera-${{ env.APP_NAME }}/argocd/dev/application.yaml"
          echo "✅ ArgoCD app applied: ${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
      - name: Refresh ECR Pull Secret on Spoke (BEFORE sync)
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASSWORD=$(aws ecr get-login-password --region ${{ env.REGION }})
          kubectl --context spoke create secret docker-registry ecr-pull-secret \
            --namespace=${{ env.NAMESPACE }} \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.REGION }}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="${ECR_PASSWORD}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -
          echo "✅ ECR pull secret refreshed"
          kubectl config use-context hub
      - name: Hard Refresh ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          sleep 5
      - name: Sync ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{"force":true}}}}}'
          for i in $(seq 1 30); do
            SYNC=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            echo "Attempt $i/30: Sync=${SYNC}, Health=${HEALTH}"
            [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ] && echo "✅ Sync completed" && break
            [ $i -eq 30 ] && kubectl --context hub get application ${ARGOCD_APP} -n argocd -o yaml && exit 1
            sleep 10
          done
      - name: Verify Deployment on Spoke
        id: verify
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          kubectl get namespace ${{ env.NAMESPACE }} --context spoke || { echo "❌ Namespace not found"; exit 1; }
          kubectl get pods -n ${{ env.NAMESPACE }} --context spoke
          kubectl wait --for=condition=Ready pods \
            -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke --timeout=300s || {
            kubectl describe pods -n ${{ env.NAMESPACE }} --context spoke; exit 1; }
          if kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke &>/dev/null; then
            kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke --timeout=300s
          fi
          echo "deployed=true" >> $GITHUB_OUTPUT
          echo "✅ Deployment verified"
          echo "## CI/CD Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`opsera-health-6-0223-dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ needs.build-push.outputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Jira | \`${{ needs.jira-create-story.outputs.issue_key }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Endpoint | \`https://opsera-health-6-0223-dev.agent.opsera.dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ✅ Deployed |" >> $GITHUB_STEP_SUMMARY

  # Stage 7: Post-Deploy Integrations
  post-deploy-integrations:
    runs-on: ubuntu-latest
    needs: [deploy, build-push, jira-create-story]
    if: always() && needs.deploy.outputs.deployed == 'true'
    steps:
      - name: Slack - Deployment Success Notification
        continue-on-error: true
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          [ -z "$SLACK_WEBHOOK_URL" ] && echo "⚠️ SLACK_WEBHOOK_URL not set" && exit 0
          curl -s -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{\"attachments\":[{\"color\":\"good\",\"title\":\"✅ Deployment Successful: ${{ env.APP_NAME }}\",\"fields\":[{\"title\":\"Environment\",\"value\":\"${{ env.ENV }}\",\"short\":true},{\"title\":\"Image Tag\",\"value\":\"`${{ needs.build-push.outputs.image-tag }}`\",\"short\":true},{\"title\":\"Jira Ticket\",\"value\":\"${{ needs.jira-create-story.outputs.issue_key }}\",\"short\":true},{\"title\":\"Endpoint\",\"value\":\"https://opsera-health-6-0223-dev.agent.opsera.dev\",\"short\":false}]}]}"
          echo "✅ Slack notification sent"

      - name: Jira - Update Story with Deployment Status
        continue-on-error: true
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
        run: |
          ISSUE_KEY="${{ needs.jira-create-story.outputs.issue_key }}"
          [ -z "$JIRA_API_TOKEN" ] || [ -z "$JIRA_BASE_URL" ] || [ "$ISSUE_KEY" = "SKIPPED" ] && exit 0
          curl -s -X POST "$JIRA_BASE_URL/rest/api/2/issue/$ISSUE_KEY/comment" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $JIRA_API_TOKEN" \
            -d "{\"body\":\"✅ Deployed to ${{ env.ENV }} successfully.\\nImage: ${{ needs.build-push.outputs.image-tag }}\\nEndpoint: https://opsera-health-6-0223-dev.agent.opsera.dev\"}"
          echo "✅ Jira story updated: $ISSUE_KEY"

      - name: New Relic - Record Deployment Marker
        continue-on-error: true
        env:
          NEWRELIC_API_KEY: ${{ secrets.NEWRELIC_API_KEY }}
          NEWRELIC_ACCOUNT_ID: ${{ secrets.NEWRELIC_ACCOUNT_ID }}
        run: |
          [ -z "$NEWRELIC_API_KEY" ] || [ -z "$NEWRELIC_ACCOUNT_ID" ] && echo "⚠️ New Relic secrets not set" && exit 0
          curl -s -X POST "https://api.newrelic.com/v2/applications/deployments.json" \
            -H "X-Api-Key: $NEWRELIC_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"deployment\":{\"revision\":\"${{ needs.build-push.outputs.image-tag }}\",\"changelog\":\"Deployed by Opsera CI/CD\",\"description\":\"${{ env.APP_NAME }} ${{ env.ENV }} deployment\",\"user\":\"github-actions\"}}"
          echo "✅ New Relic deployment marker recorded"

      - name: Datadog - Record Deployment Event
        continue-on-error: true
        env:
          DD_API_KEY: ${{ secrets.DATADOG_API_KEY }}
        run: |
          [ -z "$DD_API_KEY" ] && echo "⚠️ DATADOG_API_KEY not set" && exit 0
          curl -s -X POST "https://api.datadoghq.com/api/v1/events" \
            -H "DD-API-KEY: $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"title\":\"Deployment: ${{ env.APP_NAME }} → ${{ env.ENV }}\",\"text\":\"Successfully deployed ${{ needs.build-push.outputs.image-tag }} to ${{ env.ENV }}\",\"alert_type\":\"success\",\"tags\":[\"service:${{ env.APP_NAME }}\",\"env:${{ env.ENV }}\",\"version:${{ needs.build-push.outputs.image-tag }}\",\"team:opsera\"]}"
          echo "✅ Datadog event recorded"

      - name: Prometheus - Verify Metrics Endpoint
        continue-on-error: true
        run: |
          echo "ℹ️ Prometheus scrapes /health endpoint via pod annotations"
          echo "   prometheus.io/scrape: true | port: 8080 | path: /health"
          echo "✅ Prometheus annotations configured in deployment.yaml"
