# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Diagnostics Workflow - new-12
# Troubleshooting tools for deployment issues (uses kubectl)
# Generated by Opsera Code-to-Cloud Enterprise v0.912
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "Diagnostics new-12"

on:
  workflow_dispatch:
    inputs:
      diagnostic_type:
        description: 'Type of diagnostic to run'
        required: true
        default: 'full-pipeline'
        type: choice
        options:
          - 'full-pipeline'
          - 'pod-logs'
          - 'argocd-debug'
          - 'force-sync'

env:
  APP_NAME: new-12
  TENANT: opsera
  AWS_REGION: us-west-2
  ECR_REPOSITORY: opsera/new-12
  HUB_CLUSTER_NAME: argocd-usw2
  SPOKE_CLUSTER_NAME: opsera-usw2-np
  ARGOCD_APP: new-12-dev
  NAMESPACE: opsera-new-12-dev

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Full Pipeline Diagnostics
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  full-diagnostics:
    name: "Full Pipeline Diagnostics"
    runs-on: ubuntu-latest
    if: github.event.inputs.diagnostic_type == 'full-pipeline'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check ECR Repository
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“¦ ECR DIAGNOSTICS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" || echo "âŒ ECR repo not found"
          
          echo ""
          echo "ğŸ“· Recent images:"
          aws ecr describe-images --repository-name "${{ env.ECR_REPOSITORY }}" \
            --query 'imageDetails | sort_by(@, &imagePushedAt) | [-5:].[imageTags[0], imagePushedAt]' \
            --output table 2>/dev/null || echo "No images found"

      - name: Configure kubectl for Hub
        run: |
          echo "ğŸ”§ Configuring kubectl for hub cluster..."
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --alias hub
          echo "âœ… kubectl configured for hub"

      - name: Check ArgoCD Application
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ”„ ARGOCD APPLICATION STATUS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          echo "ğŸ“‹ Application details:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o yaml --context hub || echo "âŒ App not found"
          
          echo ""
          echo "ğŸ”„ Sync Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.sync.status}' --context hub
          echo ""
          
          echo "ğŸ¥ Health Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.health.status}' --context hub
          echo ""

      - name: Configure kubectl for Spoke
        run: |
          echo "ğŸ”§ Configuring kubectl for spoke cluster..."
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER_NAME }} --region ${{ env.AWS_REGION }} --alias spoke
          echo "âœ… kubectl configured for spoke"

      - name: Check Pods in Spoke
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” POD STATUS IN SPOKE CLUSTER"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          echo "ğŸ“‹ Pods in namespace ${{ env.NAMESPACE }}:"
          kubectl get pods -n ${{ env.NAMESPACE }} --context spoke || echo "No pods found or namespace doesn't exist"
          
          echo ""
          echo "ğŸ“‹ Deployments:"
          kubectl get deployments -n ${{ env.NAMESPACE }} --context spoke || echo "No deployments found"
          
          echo ""
          echo "ğŸ“‹ Services:"
          kubectl get services -n ${{ env.NAMESPACE }} --context spoke || echo "No services found"
          
          echo ""
          echo "ğŸ“‹ Ingress:"
          kubectl get ingress -n ${{ env.NAMESPACE }} --context spoke || echo "No ingress found"

      - name: Check Pod Events
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“œ POD EVENTS"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' --context spoke | tail -20 || echo "No events"

      - name: Check Application Health
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ¥ HEALTH CHECK"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          URL="https://opsera-new-12-dev.agent.opsera.dev/health"
          echo "Checking: ${URL}"
          
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${URL}" --max-time 10 2>/dev/null || echo "000")
          
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "âœ… Health check passed (HTTP ${HTTP_STATUS})"
          else
            echo "âŒ Health check failed (HTTP ${HTTP_STATUS})"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Pod Logs
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  pod-logs:
    name: "Pod Logs"
    runs-on: ubuntu-latest
    if: github.event.inputs.diagnostic_type == 'pod-logs'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Spoke
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Get Pod Logs
        run: |
          echo "ğŸ“‹ Pods in namespace ${{ env.NAMESPACE }}:"
          kubectl get pods -n ${{ env.NAMESPACE }}
          
          echo ""
          echo "ğŸ“œ Getting logs from all pods..."
          for pod in $(kubectl get pods -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}'); do
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ“œ Logs for pod: $pod"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            kubectl logs $pod -n ${{ env.NAMESPACE }} --tail=100 || echo "Unable to get logs"
          done

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ArgoCD Debug
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  argocd-debug:
    name: "ArgoCD Debug"
    runs-on: ubuntu-latest
    if: github.event.inputs.diagnostic_type == 'argocd-debug'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Debug ArgoCD
        run: |
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ” ARGOCD DEBUG"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          
          echo "ğŸ“‹ Application YAML:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o yaml
          
          echo ""
          echo "ğŸ”„ Sync Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.sync}'
          echo ""
          
          echo ""
          echo "ğŸ¥ Health Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.health}'
          echo ""
          
          echo ""
          echo "ğŸ“œ Conditions:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.conditions}'
          echo ""

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Force Sync
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  force-sync:
    name: "Force Sync"
    runs-on: ubuntu-latest
    if: github.event.inputs.diagnostic_type == 'force-sync'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Force Sync Application
        run: |
          echo "ğŸ”„ Force syncing application via annotation..."
          
          # Trigger hard refresh
          kubectl patch application ${{ env.ARGOCD_APP }} -n argocd \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          
          echo "â³ Waiting for sync..."
          sleep 30
          
          echo ""
          echo "ğŸ“‹ Application status after sync:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd
          
          echo ""
          echo "ğŸ”„ Sync Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.sync.status}'
          echo ""
          
          echo "ğŸ¥ Health Status:"
          kubectl get application ${{ env.ARGOCD_APP }} -n argocd -o jsonpath='{.status.health.status}'
          echo ""
