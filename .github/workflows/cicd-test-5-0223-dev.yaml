name: "CI/CD: test-5-0223-dev"

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "**/*.md"
      - ".github/workflows/**"
      - ".opsera-**/**"
      - "**/deployment-landscape-*.yaml"
  workflow_dispatch:
    inputs:
      action:
        description: "Action (deploy|rollback)"
        default: deploy

concurrency:
  group: ci-cd-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  APP_NAME: "test-5-0223"
  TENANT: "opsera"
  ENV: "dev"
  REGION: "us-west-2"
  ECR_REPO: "test-5-0223"
  NAMESPACE: "opsera-test-5-0223-dev"
  HUB_CLUSTER: "argocd-usw2"
  SPOKE_CLUSTER: "opsera-usw2-np"

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  # Stage 0: Bootstrap Prerequisites Check (BLOCKING - v0.934 RULE 234)
  bootstrap-check:
    runs-on: ubuntu-latest
    outputs:
      ready: ${{ steps.check.outputs.ready }}
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Check Bootstrap Prerequisites
        id: check
        run: |
          FAILED=0
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPO }} --region ${{ env.REGION }} &>/dev/null; then
            echo "❌ ECR repository '${{ env.ECR_REPO }}' does not exist"
            echo "   Run: gh workflow run 00-bootstrap-test-5-0223.yaml"
            FAILED=1
          else
            echo "✅ ECR repository exists"
          fi
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          if ! kubectl get namespace ${{ env.NAMESPACE }} --context spoke &>/dev/null; then
            echo "⚠️  Namespace '${{ env.NAMESPACE }}' does not exist (will be created by ArgoCD)"
          else
            echo "✅ Namespace exists"
          fi
          [ $FAILED -eq 1 ] && exit 1
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "✅ All bootstrap prerequisites satisfied"

  # Stage 1: Security Scan (warn-only - RULE 224)
  security-scan:
    runs-on: ubuntu-latest
    needs: bootstrap-check
    if: needs.bootstrap-check.outputs.ready == 'true'
    continue-on-error: true
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - name: Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
      - name: Upload Gitleaks report
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: gitleaks-report-${{ github.sha }}
          path: results.sarif
          retention-days: 30

  # Stage 2: Build and Push
  build-push:
    runs-on: ubuntu-latest
    needs: [bootstrap-check, security-scan]
    if: always() && needs.bootstrap-check.outputs.ready == 'true' && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped' || needs.security-scan.result == 'failure')
    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}
      ecr-uri: ${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}
    steps:
      - uses: actions/checkout@v4
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Login to ECR
        id: login
        uses: aws-actions/amazon-ecr-login@v2
      - name: Set image tag (RULE 175 - ENV-SHA-TIMESTAMP)
        id: tag
        run: |
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          TAG="${{ env.ENV }}-${SHORT_SHA}-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${TAG}" >> $GITHUB_ENV
      - name: Build and push
        run: |
          IMAGE_URI="${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}:${{ steps.tag.outputs.tag }}"
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfile -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}

  # Stage 3: Container Scan (warn-only - RULE 224)
  container-scan:
    runs-on: ubuntu-latest
    needs: build-push
    if: always() && needs.build-push.result == 'success'
    continue-on-error: true
    permissions:
      security-events: write
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2
      - name: Grype Vulnerability Scan
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: "${{ needs.build-push.outputs.ecr-uri }}:${{ needs.build-push.outputs.image-tag }}"
          fail-build: false
          severity-cutoff: ${{ vars.GRYPE_FAIL_SEVERITY || 'critical' }}
          output-format: sarif
      - name: Upload SARIF to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true
        with:
          sarif_file: results.sarif
      - name: Upload scan artifact
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: grype-scan-${{ env.ENV }}-${{ needs.build-push.outputs.image-tag }}
          path: results.sarif
          retention-days: 30

  # Stage 4: Update Manifests (RULE 209 - idempotent, RULE 131/234 - newName pattern)
  update-manifests:
    runs-on: ubuntu-latest
    needs: [build-push, container-scan]
    if: always() && needs.build-push.result == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      - name: Update image tag in kustomization
        run: |
          KUSTOMIZATION=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENV }}/kustomization.yaml"
          ECR_URI="${{ needs.build-push.outputs.ecr-uri }}"
          IMAGE_TAG="${{ needs.build-push.outputs.image-tag }}"
          # RULE 131/234: Replace newName (first run: placeholder → ECR URI; subsequent: no-op)
          sed -i "s|newName: PLACEHOLDER_ECR_URI|newName: ${ECR_URI}|" "${KUSTOMIZATION}"
          # Replace newTag on every run (matches any existing value)
          sed -i "s/newTag: .*/newTag: ${IMAGE_TAG}/" "${KUSTOMIZATION}"
          echo "Updated: ${ECR_URI}:${IMAGE_TAG}"
          cat "${KUSTOMIZATION}"
      - name: Commit and push [skip ci]
        run: |
          git config user.name "opsera-agent"
          git config user.email "agent@opsera.dev"
          git add .opsera-${{ env.APP_NAME }}/k8s/
          git diff --staged --quiet || git commit -m "ci: update image tag ${{ needs.build-push.outputs.image-tag }} [skip ci]"
          git push || (git pull --rebase && git push)

  # Stage 5: Deploy (ArgoCD App + ECR Secret + Sync + Verify)
  deploy:
    runs-on: ubuntu-latest
    needs: update-manifests
    if: always() && needs.update-manifests.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
      - name: Connect to Hub Cluster (ArgoCD)
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.REGION }} --alias hub
          kubectl config use-context hub
      - name: Create/Update ArgoCD Application (Idempotent - Stage 7 RULE 213)
        run: |
          kubectl --context hub apply -f ".opsera-${{ env.APP_NAME }}/argocd/dev/application.yaml"
          echo "✅ ArgoCD app applied: ${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
      - name: Refresh ECR Pull Secret on Spoke (BEFORE sync - RULE 163)
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASSWORD=$(aws ecr get-login-password --region ${{ env.REGION }})
          kubectl --context spoke create secret docker-registry ecr-pull-secret \
            --namespace=${{ env.NAMESPACE }} \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.REGION }}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="${ECR_PASSWORD}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -
          echo "✅ ECR pull secret refreshed on spoke"
          kubectl config use-context hub
      - name: Hard Refresh ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          sleep 5
          echo "✅ Hard refresh triggered"
      - name: Sync ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{"force":true}}}}}'
          echo "Waiting for sync..."
          for i in $(seq 1 30); do
            SYNC=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            echo "Attempt $i/30: Sync=${SYNC}, Health=${HEALTH}"
            if [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ]; then
              echo "✅ Sync completed"; break
            fi
            if [ $i -eq 30 ]; then
              echo "⚠️ Sync timeout"
              kubectl --context hub get application ${ARGOCD_APP} -n argocd -o yaml
              exit 1
            fi
            sleep 10
          done
      - name: Verify Deployment on Spoke
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          kubectl get namespace ${{ env.NAMESPACE }} --context spoke || { echo "❌ Namespace not found"; exit 1; }
          kubectl get pods -n ${{ env.NAMESPACE }} --context spoke
          kubectl wait --for=condition=Ready pods \
            -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke --timeout=300s || {
            echo "❌ Pods not ready"
            kubectl describe pods -n ${{ env.NAMESPACE }} --context spoke
            exit 1
          }
          if kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke &>/dev/null; then
            kubectl rollout status deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --context spoke --timeout=300s
          fi
          echo "✅ Deployment verified"
          echo "## CI/CD Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`opsera-test-5-0223-dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ needs.build-push.outputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ env.NAMESPACE }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Endpoint | \`https://opsera-test-5-0223-dev.agent.opsera.dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ✅ Deployed |" >> $GITHUB_STEP_SUMMARY
