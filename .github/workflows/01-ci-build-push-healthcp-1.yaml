# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI/CD BUILD & PUSH - healthcp-1
# Generated by Code-to-Cloud Enterprise v0.903
# RULE 10: Verify bootstrap before CI/CD
# RULE 66: Force ArgoCD sync after manifest updates
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "01-CI Build Push: healthcp-1"

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'vite.config.ts'
      - 'Dockerfile'
      - 'nginx.conf'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: string
        default: 'dev'

env:
  APP_NAME: healthcp-1
  TENANT: opsera
  AWS_REGION: us-west-2
  EKS_HUB_CLUSTER: argocd-usw2
  EKS_SPOKE_CLUSTER: opsera-usw2-np
  ECR_REPOSITORY: opsera/healthcp-1
  DOMAIN: agent.opsera.dev

permissions:
  contents: write
  id-token: write

# Prevent duplicate runs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERIFY BOOTSTRAP (RULE 10)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-bootstrap:
    name: "ğŸ” Verify Bootstrap"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      ecr_uri: ${{ steps.ecr.outputs.uri }}
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            ENVIRONMENT="dev"
          else
            ENVIRONMENT="${{ inputs.environment }}"
          fi
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Check ECR Repository Exists
        id: ecr
        env:
          AWS_ACCOUNT_ID: ${{ steps.aws-account.outputs.account_id }}
        run: |
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          
          if aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} > /dev/null 2>&1; then
            echo "âœ… ECR repository exists"
            echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT
          else
            echo "âŒ ECR repository not found. Run bootstrap first!"
            exit 1
          fi

      - name: Generate Image Tag
        id: tag
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Image Tag: ${IMAGE_TAG}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-and-push:
    name: "ğŸ”¨ Build & Push"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ needs.verify-bootstrap.outputs.ecr_uri }}

      - name: Build Docker Image
        env:
          ECR_URI: ${{ needs.verify-bootstrap.outputs.ecr_uri }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          docker build \
            --tag ${ECR_URI}:${IMAGE_TAG} \
            --tag ${ECR_URI}:latest \
            --file Dockerfile \
            .

      - name: Push to ECR
        env:
          ECR_URI: ${{ needs.verify-bootstrap.outputs.ecr_uri }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest
          echo "âœ… Image pushed: ${ECR_URI}:${IMAGE_TAG}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ğŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-and-push]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Pull Latest Changes (RULE 8)
        run: |
          git pull --rebase origin main

      - name: Update Kustomization Image Tag
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          KUSTOMIZE_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml"
          
          # Update newTag
          sed -i "s/newTag: .*/newTag: ${IMAGE_TAG}/" ${KUSTOMIZE_FILE}
          
          echo "âœ… Updated image tag to: ${IMAGE_TAG}"
          cat ${KUSTOMIZE_FILE}

      - name: Commit and Push
        env:
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .opsera-${{ env.APP_NAME }}/
          
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: Update image tag to ${IMAGE_TAG} [skip ci]"
            git pull --rebase origin main
            git push origin main
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYNC & DEPLOY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sync-and-deploy:
    name: "ğŸš€ Sync & Deploy"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, update-manifests]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Force ArgoCD Sync (RULE 66)
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
        run: |
          APP_NAME="${{ env.APP_NAME }}-${ENVIRONMENT}"
          
          # Force hard refresh
          kubectl annotate application ${APP_NAME} -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite
          
          echo "âœ… ArgoCD sync triggered for ${APP_NAME}"

      - name: Wait for Sync
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
        run: |
          APP_NAME="${{ env.APP_NAME }}-${ENVIRONMENT}"
          
          echo "Waiting for ArgoCD sync..."
          
          for i in {1..24}; do
            SYNC_STATUS=$(kubectl get application ${APP_NAME} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH_STATUS=$(kubectl get application ${APP_NAME} -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            
            echo "Attempt ${i}/24: Sync=${SYNC_STATUS}, Health=${HEALTH_STATUS}"
            
            if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
              echo "âœ… Application synced and healthy"
              exit 0
            fi
            
            sleep 10
          done
          
          echo "âš ï¸ Sync timeout - check ArgoCD for details"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ğŸ“‹ Summary"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-and-push, update-manifests, sync-and-deploy]
    if: always()
    steps:
      - name: Generate Summary
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          HOSTNAME="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENVIRONMENT}.${{ env.DOMAIN }}"
          
          cat << EOF >> $GITHUB_STEP_SUMMARY
          # ğŸ“‹ CI/CD Summary: ${{ env.APP_NAME }}
          
          ## Build Details
          | Setting | Value |
          |---------|-------|
          | **App Name** | \`${{ env.APP_NAME }}\` |
          | **Environment** | \`${ENVIRONMENT}\` |
          | **Image Tag** | \`${IMAGE_TAG}\` |
          | **Commit** | \`${{ github.sha }}\` |
          
          ## Pipeline Status
          | Stage | Status |
          |-------|--------|
          | Verify Bootstrap | ${{ needs.verify-bootstrap.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |
          | Build & Push | ${{ needs.build-and-push.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |
          | Update Manifests | ${{ needs.update-manifests.result == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |
          | Sync & Deploy | ${{ needs.sync-and-deploy.result == 'success' && 'âœ… Passed' || 'âš ï¸ Check ArgoCD' }} |
          
          ## Application URL
          \`\`\`
          https://${HOSTNAME}
          \`\`\`
          
          ## Next Steps
          - Check application status in ArgoCD
          - Verify the application is accessible
          - Run diagnostics if issues: \`gh workflow run "diagnostics-healthcp-1.yaml"\`
          EOF
