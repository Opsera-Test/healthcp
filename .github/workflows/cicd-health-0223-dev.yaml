# CI/CD Workflow Template - Single Service (7 stages)
# Substitute: health-0223, opsera, dev, us-west-2, main, opsera/health-0223
# RULE 175: Image tag format = ENV-SHA-TIMESTAMP (IMMUTABLE)
# RULE 224: Gitleaks/Grype warn mode by default

name: "CI/CD: health-0223-dev"

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "**/*.md"
      - ".github/workflows/deployment-landscape-*.yaml"
  workflow_dispatch:
    inputs:
      action:
        description: "Action (deploy|rollback)"
        default: deploy

env:
  APP_NAME: "health-0223"
  TENANT: "opsera"
  ENV: "dev"
  REGION: "us-west-2"
  ECR_REPO: "opsera/health-0223"
  NAMESPACE: "opsera-health-0223-dev"

jobs:
  # Stage 1-2: Security Scan
  security-scan:
    runs-on: ubuntu-latest
    # RULE 224: Job-level continue-on-error — defaults warn when GITLEAKS_MODE not set
    continue-on-error: ${{ vars.GITLEAKS_MODE != 'block' }}
    permissions:
      contents: read
      security-events: write  # Required for GitHub Security tab SARIF upload
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Gitleaks Secret Scan
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true  # RULE 224: Step non-blocking, controlled at job level
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: Upload Gitleaks report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-report-${{ github.sha }}
          path: results.sarif
          retention-days: 30  # 30-day retention for audit trail
        continue-on-error: true

  # Stage 1B: Code Quality Scan (SonarQube) — runs after Gitleaks, before build
  sonarqube-scan:
    runs-on: ubuntu-latest
    needs: security-scan
    if: ${{ vars.SONARQUBE_ENABLED == 'true' }}
    continue-on-error: ${{ vars.SONARQUBE_MODE != 'block' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history required for SonarQube blame analysis

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ vars.SONAR_HOST_URL }}

      - name: Quality Gate Check
        if: ${{ vars.SONARQUBE_MODE == 'block' }}
        uses: sonarsource/sonarqube-quality-gate-action@master
        timeout-minutes: 5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # Stage 3-4: Build and Push
  build-push:
    runs-on: ubuntu-latest
    needs: [security-scan, sonarqube-scan]
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped')
    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}
      ecr-uri: ${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Login to ECR
        id: login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tag
        id: tag
        run: |
          TAG="${{ env.ENV }}-${GITHUB_SHA::8}-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${TAG}" >> $GITHUB_ENV

      - name: Build and push
        run: |
          IMAGE_URI="${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}:${{ steps.tag.outputs.tag }}"
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfile -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}

  # Stage 5: Container Scan
  container-scan:
    runs-on: ubuntu-latest
    needs: build-push
    # RULE 224: Job-level continue-on-error — defaults warn when GRYPE_MODE not set
    continue-on-error: ${{ vars.GRYPE_MODE != 'block' }}
    permissions:
      security-events: write  # Required for GitHub Security tab SARIF upload
    steps:
      - name: Grype Vulnerability Scan
        id: grype
        uses: anchore/scan-action@v3
        continue-on-error: true  # RULE 224: Step also non-blocking
        with:
          image: "${{ needs.build-push.outputs.ecr-uri }}:${{ needs.build-push.outputs.image-tag }}"
          fail-build: false  # RULE 224: Never fail at scan level — controlled at job level
          severity-cutoff: ${{ vars.GRYPE_FAIL_SEVERITY || 'critical' }}
          output-format: sarif

      - name: Upload SARIF to GitHub Security tab
        if: always()  # RULE 224: Upload even if scan step failed
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true  # RULE 224: CRITICAL — don't block pipeline on upload failure
        with:
          sarif_file: results.sarif

      - name: Upload scan report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-scan-${{ env.ENV }}-${{ needs.build-push.outputs.image-tag }}
          path: results.sarif
          retention-days: 30  # Configurable: 30-day retention for audit trail

  # Stage 6: Update Manifests
  update-manifests:
    runs-on: ubuntu-latest
    needs: [build-push, container-scan]
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Update image tag
        run: |
          cd .opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENV }}
          sed -i "s|PLACEHOLDER_ECR_URI|${{ needs.build-push.outputs.ecr-uri }}|g" kustomization.yaml
          sed -i "s|PLACEHOLDER_IMAGE_TAG|${{ needs.build-push.outputs.image-tag }}|g" kustomization.yaml

      - name: Commit and push
        run: |
          git config user.name "opsera-agent"
          git config user.email "agent@opsera.dev"
          git add .opsera-${{ env.APP_NAME }}/k8s/
          git diff --staged --quiet || git commit -m "ci: update image tag ${{ needs.build-push.outputs.image-tag }} [skip ci]"
          git push

  # Stage 7: Deploy and Verify
  deploy:
    runs-on: ubuntu-latest
    needs: update-manifests
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Trigger ArgoCD sync
        run: |
          gh workflow run apply-argocd-app.yaml \
            -f app_name=${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }} \
            -f environment=${{ env.ENV }}
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Verify deployment
        run: |
          echo "Monitoring ArgoCD sync..."
          for i in $(seq 1 20); do
            STATUS=$(gh api repos/${{ github.repository }}/actions/workflows \
              --jq '.workflows[] | select(.name | contains("argocd-sync")) | .state' 2>/dev/null || echo "unknown")
            if [ "$STATUS" = "completed" ]; then
              echo "✅ Deployment verified"
              exit 0
            fi
            echo "Attempt $i/20 - waiting 30s..."
            sleep 30
          done
          echo "⚠️ Deployment verification timeout"
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
