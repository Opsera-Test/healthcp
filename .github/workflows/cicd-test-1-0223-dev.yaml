name: "CI/CD: test-1-0223-dev"

on:
  push:
    branches: ["main"]
    paths-ignore:
      - "**/*.md"
      - ".github/workflows/00-bootstrap-test-1-0223.yaml"
      - ".github/workflows/deployment-landscape-*.yaml"
  workflow_dispatch:
    inputs:
      action:
        description: "Action (deploy|rollback)"
        default: deploy

env:
  APP_NAME: "test-1-0223"
  TENANT: "opsera"
  ENV: "dev"
  REGION: "us-west-2"
  ECR_REPO: "test-1-0223"
  NAMESPACE: "opsera-test-1-0223-dev"
  HUB_CLUSTER: "argocd-usw2"
  SPOKE_CLUSTER: "opsera-usw2-np"

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  # ── Stage 1: Security Scan ────────────────────────────────────────────────
  security-scan:
    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: read
      security-events: write
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: Upload Gitleaks report
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: gitleaks-report-${{ github.sha }}
          path: results.sarif
          retention-days: 30

  # ── Stage 2: Build & Push ─────────────────────────────────────────────────
  build-push:
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'skipped' || needs.security-scan.result == 'failure')
    outputs:
      image-tag: ${{ steps.tag.outputs.tag }}
      ecr-uri: ${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Login to ECR
        id: login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image tag
        id: tag
        run: |
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:8}"
          TAG="${{ env.ENV }}-${SHORT_SHA}-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

      - name: Build and push
        run: |
          IMAGE_URI="${{ steps.login.outputs.registry }}/${{ env.ECR_REPO }}:${{ steps.tag.outputs.tag }}"
          docker build -f .opsera-${{ env.APP_NAME }}/Dockerfile -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}

  # ── Stage 3: Container Scan ───────────────────────────────────────────────
  container-scan:
    runs-on: ubuntu-latest
    needs: build-push
    if: always() && needs.build-push.result == 'success'
    continue-on-error: true
    permissions:
      security-events: write
      id-token: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Grype Vulnerability Scan
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: "${{ needs.build-push.outputs.ecr-uri }}:${{ needs.build-push.outputs.image-tag }}"
          fail-build: false
          severity-cutoff: ${{ vars.GRYPE_FAIL_SEVERITY || 'critical' }}
          output-format: sarif

      - name: Upload SARIF to GitHub Security tab
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        continue-on-error: true
        with:
          sarif_file: results.sarif

      - name: Upload scan report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-scan-${{ env.ENV }}-${{ needs.build-push.outputs.image-tag }}
          path: results.sarif
          retention-days: 30

  # ── Stage 4: Update Manifests ─────────────────────────────────────────────
  update-manifests:
    runs-on: ubuntu-latest
    needs: [build-push, container-scan]
    if: always() && needs.build-push.result == 'success'
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Update image tag in kustomization
        run: |
          KUSTOMIZATION=".opsera-${{ env.APP_NAME }}/k8s/overlays/${{ env.ENV }}/kustomization.yaml"
          ECR_URI="${{ needs.build-push.outputs.ecr-uri }}"
          IMAGE_TAG="${{ needs.build-push.outputs.image-tag }}"
          # Robust sed — replaces on every run, not just first
          sed -i "s|newName:.*|newName: ${ECR_URI}|g" "${KUSTOMIZATION}"
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "${KUSTOMIZATION}"
          echo "Updated kustomization: ${ECR_URI}:${IMAGE_TAG}"
          cat "${KUSTOMIZATION}"

      - name: Commit and push
        run: |
          git config user.name "opsera-agent"
          git config user.email "agent@opsera.dev"
          git add .opsera-${{ env.APP_NAME }}/k8s/
          git diff --staged --quiet || git commit -m "ci: update image tag ${{ needs.build-push.outputs.image-tag }} [skip ci]"
          git push || (git pull --rebase && git push)

  # ── Stage 5: Deploy ───────────────────────────────────────────────────────
  deploy:
    runs-on: ubuntu-latest
    needs: update-manifests
    if: always() && needs.update-manifests.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/

      - name: Connect to Hub Cluster (ArgoCD)
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.REGION }} --alias hub
          kubectl config use-context hub

      - name: Create/Update ArgoCD Application (Idempotent)
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub apply -f ".opsera-${{ env.APP_NAME }}/argocd/application.yaml"
          echo "✅ ArgoCD application applied: ${ARGOCD_APP}"

      - name: Refresh ECR Pull Secret on Spoke (before sync)
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASSWORD=$(aws ecr get-login-password --region ${{ env.REGION }})
          kubectl --context spoke create secret docker-registry ecr-pull-secret \
            --namespace=${{ env.NAMESPACE }} \
            --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.REGION }}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="${ECR_PASSWORD}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -
          echo "✅ ECR pull secret refreshed"
          kubectl config use-context hub

      - name: Hard Refresh ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge \
            -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
          sleep 5
          echo "✅ Hard refresh triggered"

      - name: Sync ArgoCD Application
        run: |
          ARGOCD_APP="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ env.ENV }}"
          kubectl --context hub patch application ${ARGOCD_APP} -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{"force":true}}}}}'

          echo "Waiting for sync to complete..."
          for i in $(seq 1 30); do
            SYNC_STATUS=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd \
              -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH_STATUS=$(kubectl --context hub get application ${ARGOCD_APP} -n argocd \
              -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            echo "Attempt $i/30: Sync=${SYNC_STATUS}, Health=${HEALTH_STATUS}"

            if [ "$SYNC_STATUS" = "Synced" ] && [ "$HEALTH_STATUS" = "Healthy" ]; then
              echo "✅ ArgoCD sync completed successfully"
              break
            fi

            if [ $i -eq 30 ]; then
              echo "⚠️ Sync timeout — check ArgoCD for details"
              kubectl --context hub get application ${ARGOCD_APP} -n argocd -o yaml
              exit 1
            fi
            sleep 10
          done

      - name: Verify Deployment on Spoke
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }} --alias spoke
          kubectl config use-context spoke

          echo "Verifying deployment in namespace: ${{ env.NAMESPACE }}"
          kubectl --context spoke get namespace ${{ env.NAMESPACE }} || { echo "❌ Namespace not found"; exit 1; }
          kubectl --context spoke get pods -n ${{ env.NAMESPACE }}

          kubectl --context spoke wait --for=condition=Ready pods \
            -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s || {
            echo "❌ Pods not ready"
            kubectl --context spoke describe pods -n ${{ env.NAMESPACE }}
            exit 1
          }

          if kubectl --context spoke get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} &>/dev/null; then
            kubectl --context spoke rollout status deployment/${{ env.APP_NAME }} \
              -n ${{ env.NAMESPACE }} --timeout=300s
          fi

          echo "✅ Deployment verified successfully"
          echo "## CI/CD Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Item | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`opsera-test-1-0223-dev\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${{ needs.build-push.outputs.image-tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ env.NAMESPACE }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ✅ Deployed |" >> $GITHUB_STEP_SUMMARY
