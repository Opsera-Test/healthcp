# ════════════════════════════════════════════════════════════════════════════
# CI/CD WORKFLOW - new-13
# Generated by Opsera Code-to-Cloud Enterprise v0.913
#
# RULE 93: Uses kubectl with EKS authentication (NOT ArgoCD CLI)
# RULE 147: Gets ECR URI dynamically in each job to avoid secret masking
# RULE 148: Explicit permissions for git operations
# ════════════════════════════════════════════════════════════════════════════
name: "01-CI/CD new-13"

on:
  push:
    branches: [main]
    paths-ignore:
      - '*.md'
      - '.github/workflows/00-bootstrap-*.yaml'
      - '.github/workflows/diagnostics-*.yaml'
  workflow_dispatch:

# RULE 148: Required permissions for git push and AWS OIDC
permissions:
  contents: write
  id-token: write

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  APP_NAME: new-13
  TENANT: opsera
  AWS_REGION: us-west-2
  ECR_REPOSITORY: opsera/new-13
  HUB_CLUSTER_NAME: argocd-usw2
  SPOKE_CLUSTER_NAME: opsera-usw2-np

jobs:
  # ──────────────────────────────────────────────────────────────────────────
  # Job 1: Security Scanning (Gitleaks)
  # ──────────────────────────────────────────────────────────────────────────
  security-scan:
    name: "Security Scan"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ──────────────────────────────────────────────────────────────────────────
  # Job 2: Build and Push to ECR (RULE 147: Dynamic ECR URI)
  # ──────────────────────────────────────────────────────────────────────────
  build-and-push:
    name: "Build & Push"
    runs-on: ubuntu-latest
    needs: [security-scan]
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # RULE 147: Get ECR URI dynamically to avoid secret masking
      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT

      - name: Generate image tag
        id: meta
        run: |
          IMAGE_TAG=$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::7}
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Generated tag: ${IMAGE_TAG}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ steps.ecr.outputs.uri }}:${{ steps.meta.outputs.image_tag }}
            ${{ steps.ecr.outputs.uri }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Run Grype vulnerability scan
        continue-on-error: true
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype ${{ steps.ecr.outputs.uri }}:${{ steps.meta.outputs.image_tag }} --fail-on critical || true

  # ──────────────────────────────────────────────────────────────────────────
  # Job 3: Update Kubernetes Manifests
  # ──────────────────────────────────────────────────────────────────────────
  update-manifests:
    name: "Update Manifests"
    runs-on: ubuntu-latest
    needs: [build-and-push]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # RULE 147: Get ECR URI dynamically
      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT

      - name: Update kustomization with new tag
        run: |
          cd .opsera-${{ env.APP_NAME }}/k8s/overlays/dev
          
          # Update the newTag in kustomization.yaml
          sed -i "s|newTag:.*|newTag: ${{ needs.build-and-push.outputs.image_tag }}|g" kustomization.yaml
          
          cat kustomization.yaml

      # RULE 143: Git Rebase Pattern - always pull before push
      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Pull latest changes first (RULE 143)
          git pull --rebase origin main
          
          git add -A
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "deploy: new-13-dev image ${{ needs.build-and-push.outputs.image_tag }}"
            git push origin main
          fi

  # ──────────────────────────────────────────────────────────────────────────
  # Job 4: Refresh ECR Credentials
  # ──────────────────────────────────────────────────────────────────────────
  refresh-ecr-secret:
    name: "Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Refresh ECR pull secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Delete and recreate secret
          kubectl delete secret ecr-credentials -n ${{ env.TENANT }}-${{ env.APP_NAME }}-dev --ignore-not-found
          
          kubectl create secret docker-registry ecr-credentials \
            --namespace=${{ env.TENANT }}-${{ env.APP_NAME }}-dev \
            --docker-server=${ECR_REGISTRY} \
            --docker-username=AWS \
            --docker-password=${ECR_TOKEN}

  # ──────────────────────────────────────────────────────────────────────────
  # Job 5: Sync ArgoCD (RULE 93: kubectl, not ArgoCD CLI)
  # ──────────────────────────────────────────────────────────────────────────
  sync-argocd:
    name: "Sync ArgoCD"
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Trigger ArgoCD sync
        run: |
          # Annotate application to trigger hard refresh
          kubectl annotate application ${{ env.APP_NAME }}-dev -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite
          
          echo "ArgoCD sync triggered for ${{ env.APP_NAME }}-dev"

      - name: Wait for sync
        run: |
          echo "Waiting for ArgoCD to sync..."
          sleep 30
          
          # Check application status
          kubectl get application ${{ env.APP_NAME }}-dev -n argocd -o jsonpath='{.status.sync.status}'
          echo ""
          kubectl get application ${{ env.APP_NAME }}-dev -n argocd -o jsonpath='{.status.health.status}'

  # ──────────────────────────────────────────────────────────────────────────
  # Job 6: Verify Deployment
  # ──────────────────────────────────────────────────────────────────────────
  verify-deployment:
    name: "Verify Deployment"
    runs-on: ubuntu-latest
    needs: [sync-argocd, build-and-push]
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Check pod status
        run: |
          echo "Waiting for pods to be ready..."
          sleep 30
          
          kubectl get pods -n ${{ env.TENANT }}-${{ env.APP_NAME }}-dev -l app=${{ env.APP_NAME }}
          kubectl get deployment -n ${{ env.TENANT }}-${{ env.APP_NAME }}-dev

      - name: Health check
        run: |
          echo "Checking application health..."
          HEALTH_URL="https://${{ env.TENANT }}-${{ env.APP_NAME }}-dev.agent.opsera.dev/health"
          
          for i in {1..5}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${HEALTH_URL} || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Health check passed! (HTTP $HTTP_CODE)"
              exit 0
            fi
            echo "Attempt $i: HTTP $HTTP_CODE - waiting..."
            sleep 10
          done
          
          echo "⚠️ Health check inconclusive - check manually at ${HEALTH_URL}"

  # ──────────────────────────────────────────────────────────────────────────
  # Job 7: Summary
  # ──────────────────────────────────────────────────────────────────────────
  summary:
    name: "Deployment Summary"
    runs-on: ubuntu-latest
    needs: [security-scan, build-and-push, update-manifests, refresh-ecr-secret, sync-argocd, verify-deployment]
    if: always()
    steps:
      - name: Print summary
        run: |
          echo "╔══════════════════════════════════════════════════════════════════╗"
          echo "║              DEPLOYMENT COMPLETE - new-13                        ║"
          echo "╠══════════════════════════════════════════════════════════════════╣"
          echo "║  Security Scan:    ${{ needs.security-scan.result }}"
          echo "║  Build & Push:     ${{ needs.build-and-push.result }}"
          echo "║  Update Manifests: ${{ needs.update-manifests.result }}"
          echo "║  ECR Secret:       ${{ needs.refresh-ecr-secret.result }}"
          echo "║  ArgoCD Sync:      ${{ needs.sync-argocd.result }}"
          echo "║  Verify:           ${{ needs.verify-deployment.result }}"
          echo "╠══════════════════════════════════════════════════════════════════╣"
          echo "║  Image Tag: ${{ needs.build-and-push.outputs.image_tag }}"
          echo "║  URL: https://opsera-new-13-dev.agent.opsera.dev"
          echo "╚══════════════════════════════════════════════════════════════════╝"
