# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI/CD BUILD & PUSH - hcp-1
# Generated by Code-to-Cloud Enterprise v1.6
# RULE 66: Forces ArgoCD sync after manifest updates
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "01: CI Build & Push (hcp-1)"

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'Dockerfile'
      - 'nginx.conf'
      - 'vite.config.ts'
      - 'tailwind.config.ts'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [dev, qa, staging]
        default: dev
      skip_build:
        description: 'Skip build (use existing image)'
        type: boolean
        default: false
      image_tag:
        description: 'Existing image tag (if skip_build=true)'
        type: string

env:
  APP_NAME: hcp-1
  AWS_REGION: us-east-1
  HUB_CLUSTER: argocd-use1
  SPOKE_CLUSTER: opsera-use1-np
  ECR_REPOSITORY: hcp-1-frontend

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup:
    name: "ðŸ” Setup & Validate"
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.vars.outputs.image_tag }}
      ecr_uri: ${{ steps.vars.outputs.ecr_uri }}
      environment: ${{ steps.vars.outputs.environment }}
      skip_build: ${{ steps.vars.outputs.skip_build }}
    
    steps:
      - name: Set Variables
        id: vars
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          # Determine environment
          if [ "${{ github.event_name }}" = "push" ]; then
            ENVIRONMENT="dev"
            SKIP_BUILD="false"
          else
            ENVIRONMENT="${{ inputs.environment }}"
            SKIP_BUILD="${{ inputs.skip_build }}"
          fi
          
          # Generate image tag
          if [ "$SKIP_BUILD" = "true" ] && [ -n "${{ inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ inputs.image_tag }}"
          else
            IMAGE_TAG="${{ github.sha }}-$(date +%Y%m%d%H%M%S)"
          fi
          
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}"
          
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "ecr_uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "skip_build=${SKIP_BUILD}" >> $GITHUB_OUTPUT
          
          echo "### ðŸ” Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${ENVIRONMENT}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${IMAGE_TAG}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Skip Build | \`${SKIP_BUILD}\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build:
    name: "ðŸ”¨ Build & Push"
    runs-on: ubuntu-latest
    needs: [setup]
    if: needs.setup.outputs.skip_build != 'true'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # RULE 68: Use Access Keys
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        env:
          ECR_URI: ${{ needs.setup.outputs.ecr_uri }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          echo "### ðŸ”¨ Building Docker Image" >> $GITHUB_STEP_SUMMARY
          
          # Build image
          docker build -t ${ECR_URI}:${IMAGE_TAG} -t ${ECR_URI}:latest .
          
          # Push to ECR
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest
          
          echo "âœ… Image pushed: \`${ECR_URI}:${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ðŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: [setup, build]
    # RULE 42: Use always() for downstream jobs
    if: always() && (needs.build.result == 'success' || needs.setup.outputs.skip_build == 'true')
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Pull Latest Changes
        run: |
          # L447: Always pull before modifying to avoid conflicts
          git pull --rebase origin main || true

      - name: Update Kustomization Image Tag
        env:
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          KUSTOMIZATION_FILE=".opsera-${{ env.APP_NAME }}/k8s/overlays/${ENVIRONMENT}/kustomization.yaml"
          
          # Update image tag using sed
          sed -i "s/newTag: .*/newTag: ${IMAGE_TAG}/" ${KUSTOMIZATION_FILE}
          
          echo "### ðŸ“ Manifest Updates" >> $GITHUB_STEP_SUMMARY
          echo "Updated \`${KUSTOMIZATION_FILE}\` with tag: \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Commit and Push Changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .
          git diff --cached --quiet || git commit -m "chore: Update image tag to ${{ needs.setup.outputs.image_tag }} [skip ci]"
          git push origin main

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SYNC ARGOCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  sync-argocd:
    name: "ðŸ”„ Sync ArgoCD"
    runs-on: ubuntu-latest
    needs: [setup, update-manifests]
    if: always() && needs.update-manifests.result == 'success'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      # RULE 66: Force ArgoCD sync (don't rely on auto-sync)
      - name: Force ArgoCD Sync
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          APP_NAME="${{ env.APP_NAME }}-${ENVIRONMENT}"
          
          echo "### ðŸ”„ ArgoCD Sync" >> $GITHUB_STEP_SUMMARY
          
          # Trigger hard refresh
          kubectl annotate application ${APP_NAME} -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite || true
          
          # Wait for sync
          sleep 10
          
          # Check sync status
          SYNC_STATUS=$(kubectl get application ${APP_NAME} -n argocd \
            -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          
          echo "**Sync Status:** \`${SYNC_STATUS}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # WAIT FOR DEPLOYMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  wait-deployment:
    name: "â³ Wait for Deployment"
    runs-on: ubuntu-latest
    needs: [setup, sync-argocd]
    if: always() && needs.sync-argocd.result == 'success'
    outputs:
      deploy_success: ${{ steps.wait.outputs.success }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Wait for Pods
        id: wait
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          NAMESPACE="${{ env.APP_NAME }}-${ENVIRONMENT}"
          
          # RULE 43: Environment-aware timeout
          TIMEOUT=300  # 5 minutes for DEV
          ELAPSED=0
          
          echo "### â³ Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "Waiting for pods in namespace \`${NAMESPACE}\`..." >> $GITHUB_STEP_SUMMARY
          
          while [ $ELAPSED -lt $TIMEOUT ]; do
            READY=$(kubectl get pods -n ${NAMESPACE} -l app=${{ env.APP_NAME }} \
              -o jsonpath='{.items[*].status.phase}' 2>/dev/null | tr ' ' '\n' | grep -c Running || echo 0)
            TOTAL=$(kubectl get pods -n ${NAMESPACE} -l app=${{ env.APP_NAME }} \
              --no-headers 2>/dev/null | wc -l | tr -d ' ')
            
            echo "Pods: ${READY}/${TOTAL} Running (${ELAPSED}s elapsed)"
            
            if [ "${TOTAL}" -gt 0 ] && [ "${READY}" -eq "${TOTAL}" ]; then
              echo "âœ… All pods running: ${READY}/${TOTAL}" >> $GITHUB_STEP_SUMMARY
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done
          
          # L450: Always set output, even on failure
          echo "âŒ Deployment timeout (${TIMEOUT}s)" >> $GITHUB_STEP_SUMMARY
          echo "success=false" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“‹ Pipeline Summary"
    runs-on: ubuntu-latest
    needs: [setup, build, update-manifests, sync-argocd, wait-deployment]
    if: always()
    
    steps:
      - name: Generate Summary
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
          DEPLOY_SUCCESS: ${{ needs.wait-deployment.outputs.deploy_success }}
        run: |
          echo "### ðŸ“‹ Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Setup | ${{ needs.setup.result == 'success' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build.result == 'success' && 'âœ…' || (needs.build.result == 'skipped' && 'â­ï¸' || 'âŒ') }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Update Manifests | ${{ needs.update-manifests.result == 'success' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Sync ArgoCD | ${{ needs.sync-argocd.result == 'success' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ${{ env.DEPLOY_SUCCESS == 'true' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          
          if [ "${DEPLOY_SUCCESS}" = "true" ]; then
            # RULE 64: Correct domain
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸŒ Application URL" >> $GITHUB_STEP_SUMMARY
            echo "https://${{ env.APP_NAME }}-${ENVIRONMENT}.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
          fi
