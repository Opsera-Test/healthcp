# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HEALTHCP: CI Build & Push
# Generated by Opsera Code-to-Cloud Enterprise v1.4
# 
# Features:
# - Multi-environment deployment (DEV â†’ QA â†’ Staging)
# - Manual promotion between environments
# - DNS automation with Route53
# - Slack & Jira notifications
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "healthcp: CI Build & Push"

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'Dockerfile'
      - 'nginx.conf'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - qa
          - staging
        default: 'dev'
      image_tag:
        description: 'Use existing image tag (skip build)'
        required: false
        type: string
      enable_slack_notifications:
        description: 'Enable Slack notifications'
        type: boolean
        default: true

env:
  APP_NAME: healthcp
  AWS_REGION: us-east-1
  ECR_REPOSITORY: healthcp
  # Hub-and-Spoke Model
  # Hub (ArgoCD management): argocd-use1
  # Spoke (Workload): opsera-use1-np (nonprod)
  ARGOCD_CLUSTER: argocd-use1
  WORKLOAD_CLUSTER: opsera-use1-np

permissions:
  contents: write
  id-token: write
  packages: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # VERIFY BOOTSTRAP
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  verify-bootstrap:
    name: "ðŸ” Verify Bootstrap"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.tag.outputs.image_tag }}
      skip_build: ${{ steps.tag.outputs.skip_build }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            ENVIRONMENT="dev"
          else
            ENVIRONMENT="${{ inputs.environment }}"
          fi
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "### ðŸŽ¯ Target Environment: \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY

      - name: Determine Image Tag
        id: tag
        run: |
          if [ -n "${{ inputs.image_tag }}" ]; then
            echo "image_tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "skip_build=true" >> $GITHUB_OUTPUT
            echo "### ðŸ“¦ Using existing image: \`${{ inputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          else
            IMAGE_TAG="${{ github.sha }}-$(date +%Y%m%d%H%M%S)"
            echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
            echo "skip_build=false" >> $GITHUB_OUTPUT
            echo "### ðŸ“¦ New image tag: \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Verify Required Workflows
        run: |
          echo "### ðŸ” Bootstrap Verification" >> $GITHUB_STEP_SUMMARY
          MISSING=0
          
          if [ -f ".github/workflows/diagnostics-healthcp.yaml" ]; then
            echo "âœ… Diagnostics workflow exists" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Missing: diagnostics-healthcp.yaml" >> $GITHUB_STEP_SUMMARY
            MISSING=$((MISSING + 1))
          fi
          
          if [ -f ".github/workflows/architecture-healthcp.yaml" ]; then
            echo "âœ… Architecture workflow exists" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Missing: architecture-healthcp.yaml" >> $GITHUB_STEP_SUMMARY
            MISSING=$((MISSING + 1))
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-and-push:
    name: "ðŸ”¨ Build & Push"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap]
    if: needs.verify-bootstrap.outputs.skip_build == 'false'
    outputs:
      image_uri: ${{ steps.build.outputs.image_uri }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          IMAGE_URI="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          
          echo "Building image: ${IMAGE_URI}"
          docker build -t ${IMAGE_URI} .
          docker push ${IMAGE_URI}
          
          echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "### ðŸ³ Image pushed: \`${IMAGE_URI}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  update-manifests:
    name: "ðŸ“ Update Manifests"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-and-push]
    # RULE 42: Use always() for jobs that should run when upstream may be skipped
    if: |
      always() &&
      needs.verify-bootstrap.result == 'success' &&
      (needs.build-and-push.result == 'success' || needs.build-and-push.result == 'skipped')

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=${ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Update Kustomize Image Tag
        env:
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
        run: |
          OVERLAY_PATH=".opsera-healthcp/k8s/overlays/${ENVIRONMENT}"
          
          # Update image tag in kustomization.yaml
          cd ${OVERLAY_PATH}
          
          # Replace ACCOUNT_ID placeholder
          sed -i "s/ACCOUNT_ID/${ACCOUNT_ID}/g" kustomization.yaml
          
          # Update image tag using kustomize
          kustomize edit set image PLACEHOLDER_IMAGE=${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}
          
          echo "### ðŸ“ Updated manifests for \`${ENVIRONMENT}\`" >> $GITHUB_STEP_SUMMARY
          echo "Image tag: \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Commit and Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .opsera-healthcp/
          git diff --cached --quiet || git commit -m "chore: Update ${ENVIRONMENT} manifests to ${IMAGE_TAG} [skip ci]"
          git push

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # MONITOR DEPLOYMENT
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  monitor-deployment:
    name: "ðŸ“Š Monitor Deployment"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, update-manifests]
    if: always() && needs.update-manifests.result == 'success'
    outputs:
      deploy_success: ${{ steps.wait.outputs.success }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          # Configure kubeconfig for workload cluster
          aws eks update-kubeconfig --name ${{ env.WORKLOAD_CLUSTER }} --region ${{ env.AWS_REGION }} --alias workload
          # Configure kubeconfig for ArgoCD hub cluster
          aws eks update-kubeconfig --name ${{ env.ARGOCD_CLUSTER }} --region ${{ env.AWS_REGION }} --alias argocd

      - name: Wait for Deployment
        id: wait
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
        run: |
          NAMESPACE="healthcp-${ENVIRONMENT}"
          
          # RULE 43: Environment-aware timeouts
          case "$ENVIRONMENT" in
            dev) TIMEOUT=300 ;;      # 5 min for rolling
            qa|staging) TIMEOUT=600 ;; # 10 min for canary/blue-green
          esac
          
          echo "Waiting for deployment in ${NAMESPACE} (timeout: ${TIMEOUT}s)..."
          
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            if [ "$ENVIRONMENT" = "dev" ]; then
              # Standard deployment
              READY=$(kubectl get deployment healthcp -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
              TOTAL=$(kubectl get deployment healthcp -n $NAMESPACE -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
            else
              # Argo Rollouts
              STATUS=$(kubectl argo rollouts status healthcp-rollout -n $NAMESPACE --timeout=10s 2>/dev/null || echo "Progressing")
              if [[ "$STATUS" == *"Healthy"* ]]; then
                echo "âœ… Rollout healthy"
                echo "success=true" >> $GITHUB_OUTPUT
                exit 0
              fi
              READY=0
              TOTAL=1
            fi
            
            echo "Ready: ${READY}/${TOTAL}"
            
            if [ "$READY" -eq "$TOTAL" ] && [ "$TOTAL" -gt 0 ]; then
              echo "âœ… Deployment ready"
              echo "success=true" >> $GITHUB_OUTPUT
              echo "### âœ… Deployment Successful" >> $GITHUB_STEP_SUMMARY
              exit 0
            fi
            
            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done
          
          # L450: Always set output, even on failure
          echo "success=false" >> $GITHUB_OUTPUT
          echo "### âŒ Deployment timed out" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SETUP DNS (RULE 55)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  setup-dns:
    name: "ðŸŒ Setup DNS"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, monitor-deployment]
    if: needs.monitor-deployment.outputs.deploy_success == 'true'
    outputs:
      dns_automated: ${{ steps.create-dns.outputs.dns_automated }}
      dns_record: ${{ steps.dns-info.outputs.record }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          # Configure kubeconfig for workload cluster
          aws eks update-kubeconfig --name ${{ env.WORKLOAD_CLUSTER }} --region ${{ env.AWS_REGION }} --alias workload
          # Configure kubeconfig for ArgoCD hub cluster
          aws eks update-kubeconfig --name ${{ env.ARGOCD_CLUSTER }} --region ${{ env.AWS_REGION }} --alias argocd

      - name: Get LoadBalancer Hostname
        id: get-lb
        run: |
          LB_HOSTNAME=$(kubectl get svc ingress-nginx-controller -n ingress-nginx \
            -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          
          if [ -z "$LB_HOSTNAME" ]; then
            echo "âš ï¸ LoadBalancer not ready or not found"
            echo "hostname=" >> $GITHUB_OUTPUT
          else
            echo "hostname=$LB_HOSTNAME" >> $GITHUB_OUTPUT
            echo "âœ… LoadBalancer: $LB_HOSTNAME" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Calculate DNS Record
        id: dns-info
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
        run: |
          FQDN="healthcp-${ENVIRONMENT}.agents.opsera.dev"
          echo "record=$FQDN" >> $GITHUB_OUTPUT
          echo "ðŸ“ DNS Record: $FQDN" >> $GITHUB_STEP_SUMMARY

      - name: Create DNS Record (Auto with Manual Fallback)
        id: create-dns
        if: steps.get-lb.outputs.hostname != ''
        env:
          HOSTED_ZONE_ID: ${{ vars.ROUTE53_HOSTED_ZONE_ID }}
          LB_HOSTNAME: ${{ steps.get-lb.outputs.hostname }}
          FQDN: ${{ steps.dns-info.outputs.record }}
        run: |
          if [ -z "$HOSTED_ZONE_ID" ]; then
            echo "âš ï¸ ROUTE53_HOSTED_ZONE_ID not configured" >> $GITHUB_STEP_SUMMARY
            echo "dns_automated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Create change batch JSON
          cat > /tmp/dns-change.json << EOF
          {
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$FQDN",
                "Type": "CNAME",
                "TTL": 300,
                "ResourceRecords": [{"Value": "$LB_HOSTNAME"}]
              }
            }]
          }
          EOF
          
          # RULE 56: Graceful degradation
          set +e
          CHANGE_OUTPUT=$(aws route53 change-resource-record-sets \
            --hosted-zone-id $HOSTED_ZONE_ID \
            --change-batch file:///tmp/dns-change.json \
            --query 'ChangeInfo.Id' \
            --output text 2>&1)
          DNS_EXIT_CODE=$?
          set -e
          
          if [ $DNS_EXIT_CODE -eq 0 ]; then
            echo "âœ… **DNS Record Created**" >> $GITHUB_STEP_SUMMARY
            echo "dns_automated=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ **DNS Automation Failed - Manual Setup Required**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“‹ Manual DNS Setup" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Record Name | \`$FQDN\` |" >> $GITHUB_STEP_SUMMARY
            echo "| Type | CNAME |" >> $GITHUB_STEP_SUMMARY
            echo "| Value | \`$LB_HOSTNAME\` |" >> $GITHUB_STEP_SUMMARY
            echo "| TTL | 300 |" >> $GITHUB_STEP_SUMMARY
            echo "dns_automated=false" >> $GITHUB_OUTPUT
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JIRA INTEGRATION (RULE 47)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  create-jira-ticket:
    name: "ðŸ“‹ Create Jira Ticket"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, monitor-deployment]
    if: needs.monitor-deployment.outputs.deploy_success == 'true'

    steps:
      - name: Create Deployment Ticket
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
        run: |
          # RULE 49: Check ALL required secrets
          if [ -z "$JIRA_API_TOKEN" ] || [ -z "$JIRA_EMAIL" ]; then
            echo "### ðŸ“‹ Jira Not Configured (Mock Mode)" >> $GITHUB_STEP_SUMMARY
            [ -z "$JIRA_API_TOKEN" ] && echo "- Missing: JIRA_API_TOKEN" >> $GITHUB_STEP_SUMMARY
            [ -z "$JIRA_EMAIL" ] && echo "- Missing: JIRA_EMAIL" >> $GITHUB_STEP_SUMMARY
            TICKET_KEY="MOCK-$(date +%s)"
            echo "Mock Ticket: ${TICKET_KEY}" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          # L458: Jira Basic auth format
          AUTH=$(echo -n "$JIRA_EMAIL:$JIRA_API_TOKEN" | base64)
          
          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Basic $AUTH" \
            -H "Content-Type: application/json" \
            "${JIRA_BASE_URL}/rest/api/3/issue" \
            -d "{
              \"fields\": {
                \"project\": {\"key\": \"DEPLOY\"},
                \"summary\": \"[${ENVIRONMENT}] healthcp deployment - ${IMAGE_TAG}\",
                \"issuetype\": {\"name\": \"Task\"},
                \"description\": {
                  \"type\": \"doc\",
                  \"version\": 1,
                  \"content\": [{
                    \"type\": \"paragraph\",
                    \"content\": [{
                      \"type\": \"text\",
                      \"text\": \"Deployment triggered by ${{ github.actor }}\"
                    }]
                  }]
                }
              }
            }")
          
          TICKET_KEY=$(echo "$RESPONSE" | jq -r '.key // "ERROR"')
          echo "### ðŸ“‹ Jira Ticket: ${TICKET_KEY}" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SLACK NOTIFICATION (RULE 53-54)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  notify-slack:
    name: "ðŸ“¢ Slack Notification"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, monitor-deployment, setup-dns]
    if: always() && (inputs.enable_slack_notifications == true || github.event_name == 'push')

    steps:
      - name: Send Slack Notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
          DEPLOY_SUCCESS: ${{ needs.monitor-deployment.outputs.deploy_success }}
          DNS_RECORD: ${{ needs.setup-dns.outputs.dns_record }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "Slack not configured - skipping"
            exit 0
          fi
          
          if [ "$DEPLOY_SUCCESS" = "true" ]; then
            STATUS_EMOJI="âœ…"
            STATUS_TEXT="Deployment Succeeded"
            COLOR="good"
          else
            STATUS_EMOJI="âŒ"
            STATUS_TEXT="Deployment Failed"
            COLOR="danger"
          fi
          
          curl -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d "{
              \"attachments\": [{
                \"color\": \"${COLOR}\",
                \"blocks\": [
                  {
                    \"type\": \"header\",
                    \"text\": {
                      \"type\": \"plain_text\",
                      \"text\": \"${STATUS_EMOJI} ${STATUS_TEXT}\",
                      \"emoji\": true
                    }
                  },
                  {
                    \"type\": \"section\",
                    \"fields\": [
                      {\"type\": \"mrkdwn\", \"text\": \"*Application:*\n\`healthcp\`\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Environment:*\n\`${ENVIRONMENT}\`\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*Image:*\n\`${IMAGE_TAG}\`\"},
                      {\"type\": \"mrkdwn\", \"text\": \"*URL:*\n\`https://${DNS_RECORD}\`\"}
                    ]
                  },
                  {
                    \"type\": \"actions\",
                    \"elements\": [{
                      \"type\": \"button\",
                      \"text\": {\"type\": \"plain_text\", \"text\": \"View Workflow\"},
                      \"url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"
                    }]
                  }
                ]
              }]
            }"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SUMMARY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“‹ Pipeline Summary"
    runs-on: ubuntu-latest
    needs: [verify-bootstrap, build-and-push, update-manifests, monitor-deployment, setup-dns]
    if: always()

    steps:
      - name: Generate Summary
        env:
          ENVIRONMENT: ${{ needs.verify-bootstrap.outputs.environment }}
          IMAGE_TAG: ${{ needs.verify-bootstrap.outputs.image_tag }}
          DEPLOY_SUCCESS: ${{ needs.monitor-deployment.outputs.deploy_success }}
          DNS_RECORD: ${{ needs.setup-dns.outputs.dns_record }}
          DNS_AUTOMATED: ${{ needs.setup-dns.outputs.dns_automated }}
        run: |
          echo "## ðŸ“‹ Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${{ needs.build-and-push.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Update Manifests | ${{ needs.update-manifests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment | ${{ needs.monitor-deployment.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DNS Setup | ${{ needs.setup-dns.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$DEPLOY_SUCCESS" = "true" ]; then
            echo "### ðŸŽ‰ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**URL:** https://${DNS_RECORD}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸš€ Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "To promote to the next environment, run:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            
            case "$ENVIRONMENT" in
              dev)
                echo "gh workflow run ci-build-push-healthcp.yaml -f environment=qa -f image_tag=${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
                ;;
              qa)
                echo "gh workflow run ci-build-push-healthcp.yaml -f environment=staging -f image_tag=${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
                ;;
              staging)
                echo "# Staging is the final environment in this chain" >> $GITHUB_STEP_SUMMARY
                ;;
            esac
            
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
