# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI BUILD & PUSH WORKFLOW - new-16
# Security, Quality, Build, Deploy, Notify - All stages integrated
# Generated by: Opsera Code-to-Cloud Enterprise v0.915
# RULE 150: Complete 7-stage pipeline
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "01-CI-Build-Push-new-16"

on:
  push:
    branches: [main]
    paths-ignore:
      - '**.md'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
      security_scan_mode:
        description: 'Security scan behavior'
        type: choice
        options: ['fail', 'warn', 'skip']
        default: 'warn'
      quality_gate_mode:
        description: 'Quality gate behavior'
        type: choice
        options: ['blocking', 'non-blocking', 'skip']
        default: 'skip'

env:
  APP_NAME: new-16
  TENANT: opsera
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  DOMAIN: agent.opsera.dev

permissions:
  contents: write
  id-token: write
  security-events: write
  pull-requests: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: Configuration & Validation
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  configure:
    name: "âš™ï¸ Configure Pipeline"
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      security_scan_mode: ${{ steps.config.outputs.security_scan_mode }}
      quality_gate_mode: ${{ steps.config.outputs.quality_gate_mode }}
      image_tag: ${{ steps.config.outputs.image_tag }}
    steps:
      - name: Determine Configuration
        id: config
        run: |
          # Get environment from input or default
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ inputs.environment }}"
            SECURITY_MODE="${{ inputs.security_scan_mode }}"
            QUALITY_MODE="${{ inputs.quality_gate_mode }}"
          else
            ENV="dev"
            SECURITY_MODE="warn"
            QUALITY_MODE="skip"
          fi
          
          # Generate image tag
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          IMAGE_TAG="${SHORT_SHA}"
          
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "security_scan_mode=${SECURITY_MODE}" >> $GITHUB_OUTPUT
          echo "quality_gate_mode=${QUALITY_MODE}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "### âš™ï¸ Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${ENV} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Mode | ${SECURITY_MODE} |" >> $GITHUB_STEP_SUMMARY
          echo "| Quality Mode | ${QUALITY_MODE} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | ${IMAGE_TAG} |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: Security Scanning - Gitleaks
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  security-gitleaks:
    name: "ðŸ”’ Gitleaks Secret Scan"
    runs-on: ubuntu-latest
    needs: configure
    if: needs.configure.outputs.security_scan_mode != 'skip'
    continue-on-error: ${{ needs.configure.outputs.security_scan_mode == 'warn' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Security Scan Summary
        if: always()
        run: |
          echo "### ðŸ”’ Gitleaks Scan Complete" >> $GITHUB_STEP_SUMMARY
          echo "Mode: \`${{ needs.configure.outputs.security_scan_mode }}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: Quality Gates - SonarQube (Optional)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  quality-sonarqube:
    name: "ðŸ“Š SonarQube Analysis"
    runs-on: ubuntu-latest
    needs: configure
    if: needs.configure.outputs.quality_gate_mode != 'skip'
    continue-on-error: ${{ needs.configure.outputs.quality_gate_mode == 'non-blocking' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=${{ env.TENANT }}-${{ env.APP_NAME }}

      - name: Quality Gate Summary
        if: always()
        run: |
          echo "### ðŸ“Š SonarQube Analysis Complete" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: Build & Push to ECR
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  build-push:
    name: "ðŸ—ï¸ Build & Push to ECR"
    runs-on: ubuntu-latest
    needs: [configure, security-gitleaks, quality-sonarqube]
    if: |
      always() && 
      (needs.security-gitleaks.result == 'success' || needs.security-gitleaks.result == 'skipped') &&
      (needs.quality-sonarqube.result == 'success' || needs.quality-sonarqube.result == 'skipped')
    outputs:
      image_tag: ${{ needs.configure.outputs.image_tag }}
      ecr_uri: ${{ steps.ecr.outputs.uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # RULE 147: Get ECR URI dynamically (avoid secret masking)
      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}"
          echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT
          echo "account_id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker Image
        run: |
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          ECR_URI="${{ steps.ecr.outputs.uri }}"
          
          docker build -t ${ECR_URI}:${IMAGE_TAG} -t ${ECR_URI}:latest .
          echo "âœ… Docker image built: ${ECR_URI}:${IMAGE_TAG}"

      - name: Run Grype Vulnerability Scan
        if: needs.configure.outputs.security_scan_mode != 'skip'
        uses: anchore/scan-action@v3
        id: grype
        with:
          image: ${{ steps.ecr.outputs.uri }}:${{ needs.configure.outputs.image_tag }}
          fail-build: false
          severity-cutoff: critical
        continue-on-error: true

      - name: Push to ECR
        run: |
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          ECR_URI="${{ steps.ecr.outputs.uri }}"
          
          docker push ${ECR_URI}:${IMAGE_TAG}
          docker push ${ECR_URI}:latest
          echo "âœ… Image pushed to ECR"

      - name: Build Summary
        run: |
          echo "### ðŸ—ï¸ Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Image | \`${{ steps.ecr.outputs.uri }}:${{ needs.configure.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Grype Scan | ${{ steps.grype.outcome || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 5: Deploy - Update Manifests & Sync ArgoCD
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  deploy:
    name: "ðŸš€ Deploy to ${{ needs.configure.outputs.environment }}"
    runs-on: ubuntu-latest
    needs: [configure, build-push]
    if: always() && needs.build-push.result == 'success'
    outputs:
      deploy_success: ${{ steps.verify.outputs.success }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # RULE 147: Get ECR URI dynamically in deploy job
      - name: Get ECR URI
        id: ecr
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}"
          echo "uri=${ECR_URI}" >> $GITHUB_OUTPUT

      # RULE 143: Pull FIRST before making changes
      - name: Pull Latest Changes
        run: |
          git pull --rebase origin main || true

      - name: Update Kustomize Image
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          ECR_URI="${{ steps.ecr.outputs.uri }}"
          
          cd .opsera-${{ env.APP_NAME }}/k8s/overlays/${ENV}
          
          # Update kustomization.yaml with new image
          cat > kustomization.yaml << EOF
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          # KUSTOMIZE OVERLAY - ${ENV} environment
          # Generated by: Opsera Code-to-Cloud Enterprise v0.915
          # Updated by CI/CD: ${{ github.sha }}
          # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          namespace: ${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}

          resources:
            - ../../base
            - namespace.yaml
            - ingress.yaml

          labels:
            - pairs:
                environment: ${ENV}
                tenant: ${{ env.TENANT }}
              includeSelectors: false

          images:
            - name: IMAGE_PLACEHOLDER
              newName: ${ECR_URI}
              newTag: "${IMAGE_TAG}"

          replicas:
            - name: ${{ env.APP_NAME }}
              count: 1
          EOF
          
          echo "âœ… Updated kustomization.yaml with image tag: ${IMAGE_TAG}"

      - name: Commit and Push Changes
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          
          git add .opsera-${{ env.APP_NAME }}/k8s/overlays/${ENV}/kustomization.yaml
          git diff --staged --quiet || git commit -m "deploy(${{ env.APP_NAME }}-${ENV}): Update image to ${IMAGE_TAG} [skip ci]"
          git push origin main || (git pull --rebase origin main && git push origin main)
          
          echo "âœ… Changes committed and pushed"

      - name: Configure kubectl for Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      # RULE 93: Use kubectl to trigger ArgoCD sync (NOT argocd CLI)
      - name: Trigger ArgoCD Sync
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          
          # Ensure ArgoCD application exists
          kubectl apply -f .opsera-${{ env.APP_NAME }}/argocd/${ENV}/application.yaml -n argocd
          
          # Trigger hard refresh
          kubectl annotate application ${{ env.APP_NAME }}-${ENV} -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite || true
          
          echo "âœ… ArgoCD sync triggered"

      - name: Verify Deployment
        id: verify
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}"
          
          echo "Waiting for ArgoCD sync..."
          sleep 30
          
          # Check sync status
          SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${ENV} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
          HEALTH_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${ENV} -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
          
          echo "Sync Status: ${SYNC_STATUS}"
          echo "Health Status: ${HEALTH_STATUS}"
          
          if [ "$SYNC_STATUS" = "Synced" ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment verified"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Deployment may still be in progress"
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 6: Refresh ECR Pull Secret
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  refresh-ecr-secret:
    name: "ðŸ” Refresh ECR Secret"
    runs-on: ubuntu-latest
    needs: [configure, deploy]
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Refresh ECR Pull Secret
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}"
          
          # Get fresh ECR token
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          
          # Update secret
          kubectl create secret docker-registry ecr-pull-secret \
            --namespace ${NAMESPACE} \
            --docker-server=${ECR_REGISTRY} \
            --docker-username=AWS \
            --docker-password="${ECR_TOKEN}" \
            --dry-run=client -o yaml | kubectl apply -f -
          
          echo "âœ… ECR pull secret refreshed"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 7: Deployment Summary
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  summary:
    name: "ðŸ“‹ Deployment Summary"
    runs-on: ubuntu-latest
    needs: [configure, build-push, deploy, refresh-ecr-secret]
    if: always()
    steps:
      - name: Generate Summary
        run: |
          ENV="${{ needs.configure.outputs.environment }}"
          IMAGE_TAG="${{ needs.configure.outputs.image_tag }}"
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# ðŸŽ‰ Deployment Complete: ${{ env.APP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Configure | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Scan | ${{ needs.configure.outputs.security_scan_mode == 'skip' && 'â­ï¸ Skipped' || 'âœ…' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Quality Gate | ${{ needs.configure.outputs.quality_gate_mode == 'skip' && 'â­ï¸ Skipped' || 'âœ…' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Build & Push | ${{ needs.build-push.result == 'success' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deploy | ${{ needs.deploy.result == 'success' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Refresh Secret | ${{ needs.refresh-ecr-secret.result == 'success' && 'âœ…' || 'â­ï¸' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| App | \`${{ env.APP_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | \`${ENV}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | \`${IMAGE_TAG}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Application URL" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **https://${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}.${{ env.DOMAIN }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ArgoCD" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”— https://argocd-usw2.${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_Generated by Opsera Code-to-Cloud Enterprise v0.915_" >> $GITHUB_STEP_SUMMARY
