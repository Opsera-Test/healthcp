# ════════════════════════════════════════════════════════════════════════════
# Vibe-Shift CI/CD: Dev Environment - healthcp-test-0219
# Bootstrap (Job 0) + Build + Push + Deploy via ArgoCD
# Generated by Opsera Vibe-Shift v1.0 — No scanning, maximum speed
# ════════════════════════════════════════════════════════════════════════════
# REQUIRED SECRETS: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, GH_PAT
# Trigger: Push to main (app source only) or workflow_dispatch
# ════════════════════════════════════════════════════════════════════════════

name: "CI/CD: Dev - healthcp-test-0219"

concurrency:
  group: ci-cd-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

on:
  push:
    branches: [main]
    paths-ignore:
      - '.opsera-healthcp-test-0219/k8s/**'
      - '.github/workflows/00-bootstrap-*.yaml'
      - '.github/workflows/deployment-landscape-*.yaml'
      - '**/*.md'
      - '**/*.disabled'
  workflow_dispatch: {}

env:
  APP_NAME: healthcp-test-0219
  TENANT: opsera
  ENV: dev
  AWS_REGION: us-west-2
  REGION_SHORT: usw2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ECR_REPO: opsera/healthcp-test-0219

jobs:
  # ─────────────────────────────────────────────────────────────────────────
  # Job 0: Bootstrap (idempotent) — ECR, ArgoCD repo, namespace, SA
  # ─────────────────────────────────────────────────────────────────────────
  bootstrap:
    name: "0️⃣ Bootstrap Infrastructure (idempotent)"
    runs-on: ubuntu-latest
    outputs:
      ecr_registry: ${{ steps.ecr_registry.outputs.registry }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR Registry
        id: ecr_registry
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "registry=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" >> $GITHUB_OUTPUT

      - name: Create ECR Repository (idempotent)
        run: |
          if aws ecr describe-repositories --repository-names "${ECR_REPO}" --region ${AWS_REGION} 2>/dev/null; then
            echo "✓ ECR repository already exists: ${ECR_REPO}"
          else
            aws ecr create-repository \
              --repository-name "${ECR_REPO}" \
              --image-tag-mutability IMMUTABLE \
              --encryption-configuration encryptionType=AES256 \
              --tags Key=tenant,Value=${TENANT} Key=app,Value=${APP_NAME} Key=managed-by,Value=opsera-c2c
            echo "✓ ECR repository created: ${ECR_REPO}"
          fi

      - name: Update kubeconfig (HUB + SPOKE)
        run: |
          aws eks update-kubeconfig --name ${HUB_CLUSTER} --region ${AWS_REGION} --alias hub
          aws eks update-kubeconfig --name ${SPOKE_CLUSTER} --region ${AWS_REGION} --alias spoke

      - name: Register GitHub repo with ArgoCD (idempotent)
        run: |
          REPO_SECRET_NAME="repo-$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')-${APP_NAME}"
          if kubectl --context hub get secret "$REPO_SECRET_NAME" -n argocd 2>/dev/null; then
            echo "✓ ArgoCD repository secret already exists"
          else
            kubectl --context hub apply -f - <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: ${REPO_SECRET_NAME}
            namespace: argocd
            labels:
              argocd.argoproj.io/secret-type: repository
          type: Opaque
          stringData:
            type: git
            url: https://github.com/${{ github.repository }}.git
            password: ${{ secrets.GH_PAT }}
            username: git
          EOF
            echo "✓ Repository registered with ArgoCD"
          fi

      - name: Create namespace (idempotent)
        run: |
          NAMESPACE="${TENANT}-${APP_NAME}-${ENV}"
          if kubectl --context spoke get namespace ${NAMESPACE} 2>/dev/null; then
            echo "✓ Namespace exists: ${NAMESPACE}"
          else
            kubectl --context spoke create namespace ${NAMESPACE}
            kubectl --context spoke label namespace ${NAMESPACE} tenant=${TENANT} app=${APP_NAME} environment=${ENV} managed-by=opsera-c2c
            echo "✓ Namespace created: ${NAMESPACE}"
          fi

      - name: Create service account (idempotent)
        run: |
          NAMESPACE="${TENANT}-${APP_NAME}-${ENV}"
          SA_NAME="${APP_NAME}-sa"
          if kubectl --context spoke get sa ${SA_NAME} -n ${NAMESPACE} 2>/dev/null; then
            echo "✓ Service account exists: ${SA_NAME}"
          else
            kubectl --context spoke create serviceaccount ${SA_NAME} -n ${NAMESPACE}
            echo "✓ Service account created: ${SA_NAME}"
          fi

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 1: Build Image
  # ─────────────────────────────────────────────────────────────────────────
  build-image:
    name: "1️⃣ Build Container Image"
    runs-on: ubuntu-latest
    needs: [bootstrap]
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
      ecr_registry: ${{ needs.bootstrap.outputs.ecr_registry }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Generate Image Tag
        id: tag
        run: |
          IMAGE_TAG="${ENV}-${GITHUB_SHA::8}-$(date +%Y%m%d%H%M%S)"
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build Docker Image
        id: build
        run: |
          ECR_REGISTRY="${{ needs.bootstrap.outputs.ecr_registry }}"
          IMAGE_TAG="${{ steps.tag.outputs.tag }}"
          docker build --platform linux/amd64 \
            --tag ${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG} \
            --file Dockerfile .
          echo "image_name=${ECR_REGISTRY}/${ECR_REPO}:${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Save image artifact
        run: docker save ${{ steps.build.outputs.image_name }} -o /tmp/image.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 2: Push to ECR
  # ─────────────────────────────────────────────────────────────────────────
  push-to-ecr:
    name: "2️⃣ Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image]
    outputs:
      image_tag: ${{ needs.build-image.outputs.image_tag }}
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: Load image
        run: docker load -i image.tar

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag and push
        id: push
        run: |
          ECR_REGISTRY="${{ needs.build-image.outputs.ecr_registry }}"
          TAG="${{ needs.build-image.outputs.image_tag }}"
          FULL_IMAGE="${ECR_REGISTRY}/${ECR_REPO}:${TAG}"
          docker push "$FULL_IMAGE"
          echo "ecr_uri=${ECR_REGISTRY}/${ECR_REPO}" >> $GITHUB_OUTPUT
          echo "✅ Pushed $FULL_IMAGE"

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 3: Update Kustomize Manifests
  # ─────────────────────────────────────────────────────────────────────────
  update-manifests:
    name: "3️⃣ Update Kustomize Manifests"
    runs-on: ubuntu-latest
    needs: [push-to-ecr]
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Update and push manifests
        run: |
          IMAGE_TAG="${{ needs.push-to-ecr.outputs.image_tag }}"
          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"
          KUSTOMIZATION=".opsera-healthcp-test-0219/k8s/overlays/dev/kustomization.yaml"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin ${{ github.ref_name }}
          sed -i.bak "s|newName:.*|newName: ${ECR_URI}|g" "$KUSTOMIZATION"
          sed -i.bak "s|newTag:.*|newTag: ${IMAGE_TAG}|g" "$KUSTOMIZATION"
          rm -f "${KUSTOMIZATION}.bak"
          git add "$KUSTOMIZATION"
          git diff --staged --quiet || git commit -m "chore(deploy): update dev image to ${IMAGE_TAG} [skip ci]"
          git push origin ${{ github.ref_name }}
          echo "✅ Manifest updated with tag: ${IMAGE_TAG}"

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 4: Create/Update ArgoCD Application
  # ─────────────────────────────────────────────────────────────────────────
  create-argocd-app:
    name: "4️⃣ Create/Update ArgoCD Application"
    runs-on: ubuntu-latest
    needs: [update-manifests]
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubeconfig (HUB)
        run: aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Apply ArgoCD Application
        run: |
          APP_FULL="${TENANT}-${APP_NAME}-${ENV}"
          cat <<EOF | kubectl --context hub apply -f -
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: ${APP_FULL}
            namespace: argocd
            labels:
              tenant: ${TENANT}
              app: ${APP_NAME}
              environment: ${ENV}
              managed-by: opsera-c2c
          spec:
            project: default
            source:
              repoURL: https://github.com/${{ github.repository }}.git
              targetRevision: ${{ github.ref_name }}
              path: .opsera-healthcp-test-0219/k8s/overlays/dev
            destination:
              name: ${SPOKE_CLUSTER}
              namespace: ${TENANT}-${APP_NAME}-${ENV}
            syncPolicy:
              automated:
                prune: false
                selfHeal: true
                allowEmpty: false
              syncOptions:
                - CreateNamespace=false
                - Replace=true
              retry:
                limit: 3
                backoff:
                  duration: 5s
                  factor: 2
                  maxDuration: 3m
          EOF
          echo "✅ ArgoCD application applied: ${APP_FULL}"

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 5: Refresh ECR Secret on SPOKE
  # ─────────────────────────────────────────────────────────────────────────
  refresh-ecr-secret:
    name: "5️⃣ Refresh ECR Secret (SPOKE)"
    runs-on: ubuntu-latest
    needs: [create-argocd-app]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to SPOKE
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Refresh ECR pull secret
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
          ECR_PASS=$(aws ecr get-login-password --region ${AWS_REGION})
          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${ACCOUNT}.dkr.ecr.${AWS_REGION}.amazonaws.com" \
            --docker-username=AWS \
            --docker-password="$ECR_PASS" \
            --namespace="${NS}" \
            --dry-run=client -o yaml | kubectl --context spoke apply -f -
          echo "✅ ECR secret refreshed in ${NS}"

      - name: Rollout restart to pick up fresh ECR credentials
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          kubectl --context spoke rollout restart deployment/${APP_NAME} -n ${NS} 2>/dev/null || echo "Deployment not yet created — ArgoCD will sync it"
          echo "✅ Rollout restart triggered"

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 6: ArgoCD Sync
  # ─────────────────────────────────────────────────────────────────────────
  sync-and-deploy:
    name: "6️⃣ Sync and Deploy (ArgoCD)"
    runs-on: ubuntu-latest
    needs: [refresh-ecr-secret]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to HUB
        run: aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub

      - name: Hard refresh and sync
        run: |
          APP_FULL="${TENANT}-${APP_NAME}-${ENV}"
          kubectl --context hub annotate application ${APP_FULL} -n argocd argocd.argoproj.io/refresh=hard --overwrite
          sleep 3
          kubectl --context hub patch application ${APP_FULL} -n argocd --type merge -p '{"operation":{"sync":{"prune":true,"syncOptions":["Replace=true"]}}}'
          for i in $(seq 1 60); do
            SYNC=$(kubectl --context hub get application ${APP_FULL} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            HEALTH=$(kubectl --context hub get application ${APP_FULL} -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            echo "[$i/60] Sync: $SYNC | Health: $HEALTH"
            [ "$SYNC" = "Synced" ] && [ "$HEALTH" = "Healthy" ] && echo "✅ Synced and healthy" && exit 0
            PHASE=$(kubectl --context hub get application ${APP_FULL} -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null)
            [ "$PHASE" = "Failed" ] && echo "❌ Sync failed" && exit 1
            sleep 5
          done
          echo "⚠️ Sync timeout — continuing to verify"
          exit 0

  # ─────────────────────────────────────────────────────────────────────────
  # Stage 7: Verify Deployment + HTTPS URL Check
  # ─────────────────────────────────────────────────────────────────────────
  verify-deployment:
    name: "7️⃣ Verify Deployment + HTTPS URL"
    runs-on: ubuntu-latest
    needs: [sync-and-deploy]
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Connect to SPOKE
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke

      - name: Verify pods and rollout
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          sleep 20
          kubectl --context spoke get pods -n $NS -o wide
          kubectl --context spoke rollout status deployment/${APP_NAME} -n $NS --timeout=180s
          echo "✅ Deployment healthy"

      - name: Health check (port-forward)
        run: |
          NS="${TENANT}-${APP_NAME}-${ENV}"
          kubectl --context spoke port-forward -n $NS deployment/${APP_NAME} 8080:8080 &
          PF_PID=$!
          sleep 5
          HTTP=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
          kill $PF_PID 2>/dev/null
          [ "$HTTP" = "200" ] || (echo "❌ Health check failed: HTTP $HTTP"; exit 1)
          echo "✅ Health check passed: HTTP $HTTP"

      - name: HTTPS URL verification
        run: |
          URL="https://${APP_NAME}-dev.agent.opsera.dev"
          echo "Verifying: $URL"
          for i in $(seq 1 10); do
            HTTP_STATUS=$(curl -sLo /dev/null -w "%{http_code}" "$URL" 2>/dev/null || echo "000")
            if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
              echo "✅ App is live: $URL (HTTP $HTTP_STATUS)"
              break
            fi
            echo "⏳ Waiting for app... ($i/10, HTTP $HTTP_STATUS)"
            sleep 30
          done

      - name: Summary
        run: |
          echo ""
          echo "╔══════════════════════════════════════════════════════════════╗"
          echo "║  ✅ DEPLOYMENT COMPLETE                                      ║"
          echo "╠══════════════════════════════════════════════════════════════╣"
          echo "║  App:    ${APP_NAME}                                        ║"
          echo "║  Env:    ${ENV}                                             ║"
          echo "║  URL:    https://${APP_NAME}-dev.agent.opsera.dev          ║"
          echo "╚══════════════════════════════════════════════════════════════╝"
